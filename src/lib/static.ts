/**
 * Generated static assets for Cloudflare Worker
 * DO NOT EDIT - This file is auto-generated by build-static.js
 */

export const staticAssets: Record<string, string | { content: string; encoding: 'base64' }> = {
  '/static/app.js': `// Game Shell Architecture - New Main Application
// Replaces monolithic GameClient with modular GameShell + GameModules

/**
 * Main Application class that coordinates the GameShell
 */
class GameApp {
    constructor() {
        this.gameShell = null;
        this.init();
    }

    init() {
        // Initialize the game shell
        this.gameShell = new GameShell();
        
        // Integrate active rooms functionality with shell
        this.integrateActiveRooms();
        
        // Load and display version information
        this.loadVersionInfo();
        
        // Initialize the shell
        this.gameShell.init();
    }

    /**
     * Integrate active rooms functionality with GameShell
     */
    integrateActiveRooms() {
        // Override shell's loadActiveRooms with existing functionality
        this.gameShell.loadActiveRooms = () => {
            this.loadActiveRooms();
        };

        // Override shell's refresh methods
        this.gameShell.startActiveRoomsRefresh = () => {
            this.startActiveRoomsRefresh();
        };

        this.gameShell.stopActiveRoomsRefresh = () => {
            this.stopActiveRoomsRefresh();
        };

        // Add refresh button handler
        const refreshBtn = document.getElementById('refresh-rooms-btn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.loadActiveRooms();
            });
        }
    }

    /**
     * Load active rooms from server
     */
    async loadActiveRooms() {
        if (this.gameShell.isRefreshing) return;
        
        this.gameShell.isRefreshing = true;
        const roomsList = document.getElementById('active-rooms-list');
        
        try {
            if (roomsList) {
                roomsList.innerHTML = '<div class="loading-rooms">Loading rooms...</div>';
            }
            
            const response = await fetch('/api/active-rooms');
            const data = await response.json();
            
            if (roomsList) {
                this.displayActiveRooms(data.rooms || []);
            }
        } catch (error) {
            console.error('Failed to load active rooms:', error);
            if (roomsList) {
                roomsList.innerHTML = '<div class="error-rooms">Failed to load rooms</div>';
            }
        } finally {
            this.gameShell.isRefreshing = false;
        }
    }

    /**
     * Display active rooms in the UI
     * CRITICAL: This function creates the room display with:
     * - Proper CSS class 'join-room-btn' (NOT 'join-room-button')
     * - Player emojis from room.players array
     * - Styled room information layout
     * DO NOT REMOVE player emoji display or change button CSS class!
     */
    displayActiveRooms(rooms) {
        const roomsList = document.getElementById('active-rooms-list');
        if (!roomsList) return;

        if (rooms.length === 0) {
            roomsList.innerHTML = '<div class="no-rooms">No active rooms</div>';
            return;
        }

        roomsList.innerHTML = '';
        
        rooms.forEach(room => {
            const roomDiv = document.createElement('div');
            roomDiv.className = 'room-item';
            
            const gameType = this.formatGameName(room.gameType || 'Unknown');
            const status = room.gameStatus || 'waiting';
            
            // Generate player emojis display
            const playerEmojis = room.players && room.players.length > 0 
                ? room.players.map(player => player.emoji).join(' ')
                : '';
            
            roomDiv.innerHTML = \`
                <div class="room-info">
                    <div class="room-title">\${gameType}</div>
                    <div class="room-code">\${room.sessionId}</div>
                    <div class="room-emojis">\${playerEmojis || 'No players yet'}</div>
                    <div class="room-time">Status: \${this.formatStatus(status)}</div>
                </div>
                <button class="join-room-btn" data-room-code="\${room.sessionId}" data-game-type="\${room.gameType}">
                    Join
                </button>
                <!--
                CRITICAL: Button MUST use class 'join-room-btn' for proper green styling!
                Do NOT change to 'join-room-button' or other class names.
                -->
            \`;
            
            // Add click handler for join button
            const joinBtn = roomDiv.querySelector('.join-room-btn');
            if (joinBtn) {
                joinBtn.addEventListener('click', () => {
                    this.gameShell.joinExistingRoom(room.sessionId, room.gameType);
                });
            }
            
            roomsList.appendChild(roomDiv);
        });
    }

    /**
     * Format game name for display
     */
    formatGameName(gameType) {
        return gameType
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    /**
     * Format room status for display
     */
    formatStatus(status) {
        switch (status) {
            case 'waiting': return 'Waiting';
            case 'playing': return 'In Progress';
            case 'finished': return 'Finished';
            default: return status;
        }
    }

    /**
     * Start auto-refresh for active rooms
     */
    startActiveRoomsRefresh() {
        // Clear any existing interval
        this.stopActiveRoomsRefresh();
        
        this.gameShell.refreshInterval = setInterval(() => {
            // Only refresh if on portal view and not in a game
            const portalView = document.getElementById('game-portal');
            if (portalView && portalView.classList.contains('active') && !this.gameShell.sessionId) {
                this.loadActiveRooms();
            }
        }, 5000); // Refresh every 5 seconds
    }

    /**
     * Stop auto-refresh
     */
    stopActiveRoomsRefresh() {
        if (this.gameShell.refreshInterval) {
            clearInterval(this.gameShell.refreshInterval);
            this.gameShell.refreshInterval = null;
        }
    }

    /**
     * Load and display version information
     */
    async loadVersionInfo() {
        try {
            const response = await fetch('/static/version.json');
            const versionInfo = await response.json();
            
            const versionDisplay = document.getElementById('version-display');
            if (versionDisplay) {
                versionDisplay.textContent = \`running version \${versionInfo.version}, last deployed on \${versionInfo.deployedAt}\`;
            }
        } catch (error) {
            console.warn('Could not load version info:', error);
            const versionDisplay = document.getElementById('version-display');
            if (versionDisplay) {
                versionDisplay.textContent = 'version info unavailable';
            }
        }
    }
}

// Initialize the application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.gameApp = new GameApp();
});`,
  '/static/favicon.ico': { content: '', encoding: 'base64' },
  '/static/favicon.png': { content: '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', encoding: 'base64' },
  '/static/index.html': `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Premium Web Games Online Incorporated LLC Esq. GPT CBD</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <link rel="shortcut icon" type="image/png" href="/static/favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div id="app">
        <header>
            <h1 class="company-name">Premium Web Games Online Incorporated LLC Esq. GPT CBD</h1>
        </header>
        
        <main>
            <!-- Game Portal View -->
            <div id="game-portal" class="view active">
                <h2>Select a Game</h2>
                <div class="games-grid">
                    <button class="game-card" data-game="checkbox-game">
                        <h3>Checkbox Game</h3>
                        <p>Not really a game lol</p>
                    </button>
                    <button class="game-card" data-game="everybody-votes">
                        <h3>Everybody Votes</h3>
                        <p>Vote, predict, and see who knows the crowd best!</p>
                    </button>
                    <button class="game-card coming-soon" data-game="paddlin-game">
                        <h3>That's a Paddlin'</h3>
                        <p>N-way pong with paddles around a shared arena</p>
                        <div class="coming-soon-badge">Coming soon maybe lol</div>
                    </button>
                    <button class="game-card" data-game="county-game">
                        <h3>County Game</h3>
                        <p>Say your county and celebrate together!</p>
                    </button>
                    <button class="game-card coming-soon" data-game="price-game">
                        <h3>The Price is Weird</h3>
                        <p>Guess prices of real Etsy products without going over</p>
                        <div class="coming-soon-badge">Coming soon maybe lol</div>
                    </button>
                </div>
                
                <div class="join-room-section">
                    <h3>Join Existing Room</h3>
                    
                    <div class="join-layout">
                        <div class="manual-join-section">
                            <div class="join-method">
                                <h4>Enter Room Code</h4>
                                <div class="manual-join">
                                    <input type="text" id="room-code-input" placeholder="ENTER CODE">
                                    <button id="join-room-btn">Join Room</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="active-rooms">
                            <div class="active-rooms-header">
                                <h4>Active Rooms</h4>
                                <button id="refresh-rooms-btn" class="refresh-btn" title="Refresh active rooms list">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                                        <path d="M1 4v6h6"></path>
                                        <path d="M23 20v-6h-6"></path>
                                        <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10"></path>
                                        <path d="M3.51 15A9 9 0 0 0 18.36 18.36L23 14"></path>
                                    </svg>
                                </button>
                            </div>
                            <div id="active-rooms-list" class="rooms-list">
                                <div class="loading-rooms">Loading rooms...</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Game Room View -->
            <div id="game-room" class="view">
                <div class="room-header">
                    <div class="header-left">
                        <div class="rules-box" id="rules-box" style="display: none;">
                            <h3>How to Play</h3>
                            <div id="game-rules-content">
                                <!-- Game-specific rules will be populated here -->
                            </div>
                        </div>
                    </div>
                    <div class="header-right">
                        <div class="room-info">
                            <h2 id="game-title">Game Room</h2>
                            <div class="room-code">Room: <span id="room-code-display"></span></div>
                        </div>
                        <button id="leave-room-btn">Leave Room</button>
                    </div>
                </div>
                
                <!-- Combined Waiting Room Container -->
                <div class="waiting-room-container" style="background: white; border: 2px solid #e0e0e0; border-radius: 12px; padding: 25px; margin: 20px 0; display: flex; gap: 40px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <!-- Players List Section (Left) -->
                    <div class="players-list" style="flex: 1; min-width: 200px;">
                        <div class="players-header" style="margin-bottom: 15px;">
                            <h3 style="margin: 0; color: #333;">Players</h3>
                            <button id="start-game-btn-header">Start Game</button>
                        </div>
                        <div id="players-container" style="background: #f8f9fa; border-radius: 8px; padding: 10px; min-height: 120px;"></div>
                    </div>
                    
                    <!-- Player Identity Section (Right) -->
                    <div id="player-controls" class="player-controls" style="flex: 1; min-width: 300px; border-left: 2px solid #e0e0e0; padding-left: 30px;">
                        <div class="player-info-container">
                            <h3 style="margin: 0 0 20px 0; color: #333;">Who Are You?</h3>
                            <div class="player-info" style="display: flex; flex-direction: column; gap: 18px;">
                                <div class="name-control responsive-name-control">
                                    <label class="name-label" style="font-weight: 600; min-width: 55px; color: #555;">Name:</label>
                                    <div class="name-input-group">
                                        <input type="text" id="player-name-input" placeholder="Enter your name" maxlength="20" class="name-input">
                                        <button id="update-name-btn" class="update-btn" onmouseover="this.style.background='#0056b3'" onmouseout="this.style.background='#007bff'">Update</button>
                                    </div>
                                </div>
                                <div class="emoji-control" style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                                    <label style="font-weight: 600; min-width: 55px; color: #555;">Avatar:</label>
                                    <button id="current-emoji-btn" style="padding: 10px 16px; background: white; border: 2px solid #007bff; border-radius: 6px; cursor: pointer; font-size: 28px; transition: all 0.2s; min-width: 60px;" onmouseover="this.style.background='#e3f2fd'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='white'; this.style.transform='scale(1)'"></button>
                                    <span style="color: #888; font-size: 13px;">Click to change</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Emoji Picker Popup (Outside container to avoid overflow issues) -->
                <div id="emoji-picker" style="display: none; position: fixed; background: white; border: 2px solid #007bff; border-radius: 10px; padding: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); z-index: 99999; width: 340px;">
                    <h4 style="margin: 0 0 12px 0; color: #333; font-size: 16px; border-bottom: 1px solid #e0e0e0; padding-bottom: 8px;">Choose Your Avatar</h4>
                    <div id="emoji-grid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; max-height: 280px; overflow-y: auto; padding: 5px;">
                        <!-- Animal emojis will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Game Area - Where all game modules render -->
                <div id="game-area" class="game-area" style="display: none;">
                    <!-- Game modules will be injected here dynamically -->
                </div>
                
                <!-- Chat Area - For in-game communication -->
                <div id="chat-area" class="chat-area" style="display: none;">
                    <div class="chat-header">
                        <h3> Game Chat</h3>
                    </div>
                    <div class="chat-main-container">
                        <div class="chat-messages-section">
                            <div class="chat-messages" id="chat-messages">
                                <!-- Chat messages will appear here -->
                            </div>
                            <div class="chat-input-area">
                                <input type="text" id="chat-input" placeholder="Type a message...">
                                <button id="chat-send-btn">Send</button>
                            </div>
                        </div>
                        <div class="chat-users-panel">
                            <div class="chat-users-list" id="chat-users-list">
                                <!-- Player and spectator list will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Universal End Game Screen -->
                <div id="end-game-screen" class="end-game-screen" style="display: none;">
                    <div class="end-game-content">
                        <h2 id="game-result-message">Game Over!</h2>
                        <div id="final-scores" class="final-scores">
                            <!-- Final scores will be populated by JavaScript -->
                        </div>
                        <button id="ok-btn" class="ok-btn">OK</button>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button id="start-game-btn" style="display: none;">Start Game</button>
                    <button id="restart-game-btn" style="display: none;">Restart Game</button>
                </div>
            </div>
        </main>
        
        <!-- Loading overlay -->
        <div id="loading-overlay" class="overlay" style="display: none;">
            <div class="spinner"></div>
            <p>Connecting...</p>
        </div>
        
        <!-- Error messages -->
        <div id="error-container" class="error-container"></div>
    </div>
    
    <!-- Version Info -->
    <footer class="version-info">
        <div id="version-display">Loading version...</div>
    </footer>
    
    <!-- Game Shell Architecture -->
    <script src="/static/js/GameModule.js"></script>
    <script src="/static/js/games/CheckboxGameModule.js"></script>
    <script src="/static/js/games/ThatsAPaddlinGameModule.js"></script>
    <script src="/static/js/games/EverybodyVotesGameModule.js"></script>
    <script src="/static/js/games/CountyGameModule.js"></script>
    <script src="/static/js/games/PriceIsWeirdGameModule.js"></script>
    <script src="/static/js/GameShell.js"></script>
    <script src="/static/app.js"></script>
</body>
</html>`,
  '/static/js/GameModule.js': `/**
 * Base GameModule interface that all games must implement
 * This defines the contract between the GameShell and individual games
 */
class GameModule {
    constructor() {
        this.gameAreaElement = null;
        this.players = {};
        this.gameState = {};
        this.isActive = false;
        this.onPlayerAction = null; // Callback to shell
        this.onStateChange = null;  // Callback to shell
    }

    /**
     * Initialize the game module
     * @param {HTMLElement} gameAreaElement - The container where game UI should be rendered
     * @param {Object} players - Current players in the room
     * @param {Object} initialState - Initial game state from server
     * @param {Function} onPlayerAction - Callback for player actions (playerId, action)
     * @param {Function} onStateChange - Callback for state changes
     * @param {HTMLElement} rulesElement - Optional DOM element for game rules
     */
    init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement) {
        this.gameAreaElement = gameAreaElement;
        this.players = players;
        this.gameState = initialState || {};
        this.onPlayerAction = onPlayerAction;
        this.onStateChange = onStateChange;
        this.rulesElement = rulesElement;
        this.isActive = true;
        
        // Populate rules if element provided and game has rules
        if (this.rulesElement && typeof this.getRules === 'function') {
            const rules = this.getRules();
            if (rules) {
                this.rulesElement.innerHTML = rules;
            }
        }
        
        this.render();
    }

    /**
     * Handle game state updates from server
     * @param {Object} gameSpecificState - New game state
     */
    handleStateUpdate(gameSpecificState) {
        this.gameState = { ...this.gameState, ...gameSpecificState };
        this.render();
    }

    /**
     * Update players data from shell
     * @param {Object} players - Updated players object
     */
    updatePlayers(players) {
        this.players = players;
        // Re-render if needed to reflect player changes (like emojis)
        this.render();
    }

    /**
     * Handle player actions (from other players via WebSocket)
     * @param {string} playerId - ID of player who performed action
     * @param {Object} action - The action data
     */
    handlePlayerAction(playerId, action) {
        // Default implementation - subclasses should override
    }

    /**
     * Check if game has ended and return win condition
     * @returns {Object|null} - {winnerId, points} or null if game continues
     */
    getWinCondition() {
        // Default implementation - subclasses should override
        return null;
    }

    /**
     * Render the game UI
     * Should update the gameAreaElement with current game state
     */
    render() {
        // Default implementation - subclasses must override
        if (this.gameAreaElement) {
            this.gameAreaElement.innerHTML = '<p>Game module not implemented</p>';
        }
    }

    /**
     * Get game rules HTML (optional - override in subclasses)
     * @returns {string|null} HTML string for game rules or null if no rules
     */
    getRules() {
        return null;
    }
    
    /**
     * Clean up resources when game module is destroyed
     */
    cleanup() {
        this.isActive = false;
        if (this.gameAreaElement) {
            this.gameAreaElement.innerHTML = '';
        }
        if (this.rulesElement) {
            this.rulesElement.innerHTML = '';
        }
        this.gameAreaElement = null;
        this.rulesElement = null;
        this.players = {};
        this.gameState = {};
        this.onPlayerAction = null;
        this.onStateChange = null;
    }

    /**
     * Get the game's display name
     * @returns {string}
     */
    getDisplayName() {
        return 'Base Game';
    }

    /**
     * Get the game's unique identifier
     * @returns {string}
     */
    getGameType() {
        return 'base';
    }

    /**
     * Check if player is allowed to perform actions (not a spectator)
     * @param {string} playerId
     * @returns {boolean}
     */
    canPlayerAct(playerId) {
        const player = this.players[playerId];
        return player && !player.isSpectator;
    }
}

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GameModule;
} else {
    window.GameModule = GameModule;
}`,
  '/static/js/GameShell.js': `/**
 * GameShell - Manages common game functionality across all games
 * Handles WebSocket connections, player management, room lifecycle, and UI shell
 */
class GameShell {
    constructor() {
        // WebSocket and connection management
        this.ws = null;
        this.sessionId = '';
        this.isConnected = false;
        
        // Player and room state
        this.currentPlayerId = null;
        this.currentPlayer = null;
        this.players = {};
        this.isSpectator = false;
        this.spectatorId = null;
        this.spectators = {};
        
        // Game state and module management
        this.gameType = '';
        this.gameModule = null;
        this.gameState = 'waiting'; // waiting, playing, finished
        this.roomState = {};
        
        // UI state
        this.currentView = 'portal';
        this.gameAreaElement = null;
        
        // Auto-refresh for active rooms
        this.refreshInterval = null;
        this.isRefreshing = false;
        
        // Chat state
        this.chatMessages = [];
    }

    /**
     * Initialize the game shell
     */
    init() {
        this.setupEventListeners();
        this.checkURLForRoom();
        this.loadActiveRooms();
        this.startActiveRoomsRefresh();
        this.initializeGameArea();
    }

    /**
     * Check URL for room code and auto-join if present
     */
    checkURLForRoom() {
        const path = window.location.pathname;
        
        // Check for game-specific paths
        if (path === '/everybody-votes') {
            console.log('Everybody Votes URL detected - auto-creating room');
            setTimeout(() => {
                this.startGame('everybody-votes');
            }, 100);
            return;
        }
        
        // Check for room codes
        const roomMatch = path.match(/^\\/([A-Z0-9]{6})$/);
        
        if (roomMatch) {
            const roomCode = roomMatch[1];
            // Auto-join the room after a short delay to ensure DOM is ready
            setTimeout(() => {
                this.joinExistingRoom(roomCode);
            }, 100);
        }
    }

    /**
     * Initialize the game area container where game modules will render
     */
    initializeGameArea() {
        this.gameAreaElement = document.getElementById('game-area');
        if (!this.gameAreaElement) {
            console.error('Game area element not found - games will not render properly');
        }
    }

    /**
     * Setup event listeners for shell functionality
     */
    setupEventListeners() {
        // Game selection
        document.querySelectorAll('.game-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const gameType = e.currentTarget.dataset.game;
                const isComingSoon = e.currentTarget.classList.contains('coming-soon');
                
                if (!isComingSoon && gameType) {
                    this.startGame(gameType);
                }
            });
        });

        // Room joining
        const joinRoomBtn = document.getElementById('join-room-btn');
        const roomCodeInput = document.getElementById('room-code-input');
        
        if (joinRoomBtn && roomCodeInput) {
            joinRoomBtn.addEventListener('click', () => this.joinRoomByCode());
            roomCodeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.joinRoomByCode();
            });
            roomCodeInput.addEventListener('input', this.formatRoomCodeInput.bind(this));
        }

        // Leave room
        const leaveBtn = document.getElementById('leave-room-btn');
        if (leaveBtn) {
            leaveBtn.addEventListener('click', () => this.leaveGame());
        }

        // Player controls
        this.setupPlayerControls();

        // Start game button
        const startGameBtn = document.getElementById('start-game-btn-header');
        if (startGameBtn) {
            startGameBtn.addEventListener('click', () => this.startGameSession());
        }
        
        // Chat controls
        this.setupChatControls();

        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            const path = window.location.pathname;
            const roomMatch = path.match(/^\\/([A-Z0-9]{6})$/);
            
            if (roomMatch && !this.sessionId) {
                // User navigated to a room URL
                const roomCode = roomMatch[1];
                this.joinExistingRoom(roomCode);
            } else if (!roomMatch && this.sessionId) {
                // User navigated back to root from a room
                this.leaveGame();
            }
        });
    }

    /**
     * Setup chat control event listeners
     */
    setupChatControls() {
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        
        if (chatInput && chatSendBtn) {
            // Enable chat when connected
            const enableChat = () => {
                if (this.isConnected && (this.gameState === 'playing' || this.gameState === 'finished')) {
                    chatInput.disabled = false;
                    chatSendBtn.disabled = false;
                }
            };
            
            // Send message handler
            const sendMessage = () => {
                const message = chatInput.value.trim();
                if (message && this.ws && this.isConnected) {
                    this.ws.send(JSON.stringify({
                        type: 'chat_message',
                        data: { message }
                    }));
                    chatInput.value = '';
                }
            };
            
            chatSendBtn.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // Store enableChat function for later use
            this.enableChat = enableChat;
        }
    }
    
    /**
     * Setup player control event listeners
     */
    setupPlayerControls() {
        const updateNameBtn = document.getElementById('update-name-btn');
        const nameInput = document.getElementById('player-name-input');
        const currentEmojiBtn = document.getElementById('current-emoji-btn');

        if (updateNameBtn && nameInput) {
            updateNameBtn.addEventListener('click', () => {
                const name = nameInput.value.trim();
                if (name) this.updatePlayerName(name);
            });
            
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const name = nameInput.value.trim();
                    if (name) this.updatePlayerName(name);
                }
            });
        }

        if (currentEmojiBtn) {
            currentEmojiBtn.addEventListener('click', () => this.showEmojiPicker());
        }

        // Close emoji picker when clicking outside
        document.addEventListener('click', (e) => {
            const picker = document.getElementById('emoji-picker');
            const emojiBtn = document.getElementById('current-emoji-btn');
            if (picker && !picker.contains(e.target) && e.target !== emojiBtn) {
                picker.style.display = 'none';
            }
        });
    }

    /**
     * Start a new game of the specified type
     */
    async startGame(gameType) {
        try {
            this.gameType = gameType;
            this.showLoadingOverlay();
            
            // Generate session ID and connect
            this.sessionId = this.generateSessionId();
            
            // Update URL to include room code
            window.history.pushState({roomCode: this.sessionId}, '', \`/\${this.sessionId}\`);
            
            await this.connectToGame();
            
        } catch (error) {
            console.error('Failed to start game:', error);
            this.showError('Failed to start game: ' + error.message);
            this.hideLoadingOverlay();
        }
    }

    /**
     * Connect to game WebSocket
     */
    connectToGame() {
        return new Promise((resolve, reject) => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const gameTypeParam = this.gameType ? \`?gameType=\${encodeURIComponent(this.gameType)}\` : '';
            const wsUrl = \`\${protocol}//\${window.location.host}/api/game/\${this.sessionId}/ws\${gameTypeParam}\`;
            
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                this.isConnected = true;
                resolve();
            };
            
            this.ws.onmessage = (event) => this.handleWebSocketMessage(event);
            this.ws.onclose = (event) => {
                this.handleWebSocketClose();
            };
            this.ws.onerror = (error) => {
                console.error(' WebSocket error:', error);
                reject(error);
            };
        });
    }

    /**
     * Handle incoming WebSocket messages
     */
    handleWebSocketMessage(event) {
        try {
            const message = JSON.parse(event.data);
            
            if (message.type === 'game_ended') {
                console.log('[GameShell] Received game_ended message:', message);
            }

            switch (message.type) {
                case 'gameState':
                    this.handleGameStateUpdate(message);
                    break;
                case 'game_started':
                    this.handleGameStarted(message);
                    break;
                case 'game_ended':
                    this.handleGameEnded(message);
                    break;
                case 'playerJoined':
                case 'playerLeft':
                case 'playerUpdated':
                    this.handlePlayerUpdate(message);
                    break;
                case 'spectator_identity':
                case 'spectator_joined':
                case 'spectator_left':
                    this.handleSpectatorUpdate(message);
                    break;
                case 'chat_message':
                    this.handleChatMessage(message);
                    break;
                case 'chat_history':
                    this.handleChatHistory(message);
                    break;
                case 'checkbox_toggled':
                    // Handle checkbox specific messages
                    if (this.gameModule && message.data) {
                        // Update players if gameState is included
                        if (message.data.gameState && message.data.gameState.players) {
                            this.players = message.data.gameState.players;
                            this.gameModule.updatePlayers(this.players);
                        }
                        const playerId = message.data.playerId || message.data.toggledBy || message.playerId;
                        this.gameModule.handlePlayerAction(playerId, message);
                    }
                    break;
                default:
                    
                    // Pass unknown messages to game module
                    if (this.gameModule && this.gameModule.handleMessage) {
                        this.gameModule.handleMessage(message);
                    }
            }
        } catch (error) {
            console.error('Error parsing WebSocket message:', error);
        }
    }

    /**
     * Handle game state updates from server
     */
    handleGameStateUpdate(message) {
        // Check if this is a spectator message
        if (message.isSpectator || message.spectatorId) {
            this.isSpectator = true;
            this.spectatorId = message.spectatorId;
        } else {
            this.currentPlayerId = message.playerId;
        }
        
        this.roomState = message.gameState;
        this.players = message.gameState.players || {};
        
        // Set currentPlayer after updating players
        if (this.currentPlayerId && this.players[this.currentPlayerId]) {
            this.currentPlayer = this.players[this.currentPlayerId];
        }
        
        // Extract game type from server state
        if (message.gameState.type) {
            this.gameType = message.gameState.type;
        }
        
        // Update spectators if present
        if (message.gameState.spectators) {
            this.spectators = message.gameState.spectators;
        }
        
        // Update game state based on server status
        if (message.gameState.gameStatus === 'finished') {
            this.gameState = 'finished';
        } else if (message.gameState.gameStatus === 'in-progress' || message.gameState.gameStarted) {
            this.gameState = 'playing';
        } else {
            this.gameState = 'waiting';
        }
        
        // Ensure view switches to room when we have a session
        if (this.sessionId && this.currentView === 'portal') {
            this.currentView = 'room';
        }
        
        this.updateUI();
        this.hideLoadingOverlay();
        
        // Load game module in waiting room to show rules
        if (this.gameState === 'waiting' && !this.gameModule && this.gameType) {
            this.loadGameModule(this.gameType).then(() => {
                if (this.gameModule) {
                    // Show rules box if game provides rules
                    this.updateRulesDisplay();
                }
            });
        }
        
        // If spectator and game is in progress, load the game module
        if (this.isSpectator && this.gameState === 'playing' && !this.gameModule) {
            this.loadGameModule(this.gameType || 'checkbox-game').then(() => {
                if (this.gameModule) {
                    this.gameModule.currentPlayerId = null; // No player ID for spectator
                    this.gameModule.isSpectator = true;
                    
                    // Get rules element
                    const rulesElement = document.getElementById('game-rules-content');
                    
                    this.gameModule.init(
                        this.gameAreaElement,
                        this.players,
                        {...message.gameState, hostId: message.gameState.hostId},
                        (action) => this.sendPlayerAction(action),
                        (state) => this.onGameStateChange(state),
                        rulesElement
                    );
                    
                    // Show rules box if game provides rules
                    this.updateRulesDisplay();
                }
            });
        }
        
        // Pass both updated players and game-specific state to module
        if (this.gameModule) {
            // Update players in the module
            this.gameModule.updatePlayers(this.players);
            
            // Pass game-specific state to module
            if (message.gameState.gameSpecificState) {
                this.gameModule.handleStateUpdate(message.gameState.gameSpecificState);
            }
        }
    }

    /**
     * Handle game started message
     */
    handleGameStarted(message) {
        this.gameState = 'playing';
        
        // Update room state if gameState is provided
        if (message.data?.gameState) {
            this.roomState = message.data.gameState;
        }
        
        // Load and initialize the appropriate game module
        this.loadGameModule(this.gameType).then(() => {
            if (this.gameModule) {
                // Pass current player context to module
                this.gameModule.currentPlayerId = this.currentPlayerId;
                this.gameModule.isSpectator = this.isSpectator;
                
                // Get rules element
                const rulesElement = document.getElementById('game-rules-content');
                
                this.gameModule.init(
                    this.gameAreaElement,
                    this.players,
                    {...(message.data?.gameSpecificState || {}), hostId: message.data?.gameState?.hostId || this.roomState.hostId},
                    (action) => this.sendPlayerAction(action),
                    (state) => this.onGameStateChange(state),
                    rulesElement
                );
                
                // Show rules box if game provides rules
                this.updateRulesDisplay();
                
                // Pass the game_started message to the module
                if (this.gameModule.handleMessage) {
                    this.gameModule.handleMessage(message);
                }
            }
        });

        this.updateUI();
    }

    /**
     * Handle game ended message
     */
    handleGameEnded(message) {
        console.log('[GameShell] handleGameEnded called, data:', message.data);
        this.gameState = 'finished';
        
        // Pass the game_ended message to the module before cleanup
        if (this.gameModule && this.gameModule.handleMessage) {
            this.gameModule.handleMessage(message);
        }
        
        // Clean up game module but keep it for potential restart
        if (this.gameModule) {
            this.gameModule.cleanup();
            // Don't set to null yet - keep reference until user leaves
        }
        
        this.showGameEndScreen(message.data);
        this.updateUI();
    }

    /**
     * Load the appropriate game module
     */
    async loadGameModule(gameType) {
        try {
            
            if (gameType === 'checkbox-game') {
                if (typeof CheckboxGameModule !== 'undefined') {
                    this.gameModule = new CheckboxGameModule();
                } else {
                    console.error('CheckboxGameModule class not found - check script loading');
                    this.gameModule = null;
                }
            } else if (gameType === 'everybody-votes') {
                if (typeof EverybodyVotesGameModule !== 'undefined') {
                    this.gameModule = new EverybodyVotesGameModule();
                } else {
                    console.error('EverybodyVotesGameModule class not found - check script loading');
                    this.gameModule = null;
                }
            } else if (gameType === 'county-game') {
                if (typeof CountyGameModule !== 'undefined') {
                    this.gameModule = new CountyGameModule();
                } else {
                    console.error('CountyGameModule class not found - check script loading');
                    this.gameModule = null;
                }
            } else {
                console.warn(\`Game module not implemented: \${gameType}\`);
                this.gameModule = null;
            }
        } catch (error) {
            console.error(\`Failed to load game module \${gameType}:\`, error);
            this.gameModule = null;
        }
    }

    /**
     * Send player action to server
     */
    sendPlayerAction(action) {
        if (this.ws && this.isConnected) {
            this.ws.send(JSON.stringify(action));
        } else {
            console.error('Cannot send action - WebSocket not connected');
        }
    }

    /**
     * Handle game state changes from modules
     */
    onGameStateChange(state) {
        // Module is notifying us of state changes
        // We can use this to update shell UI or send to server
    }

    /**
     * Update the main UI elements
     */
    updateUI() {
        this.updateView();
        this.updateRoomInfo();
        this.updatePlayersList();
        this.updateGameControls();
    }

    /**
     * Switch between portal and game room views
     */
    updateView() {
        const portalView = document.getElementById('game-portal');
        const roomView = document.getElementById('game-room');
        
        if (this.currentView === 'portal') {
            portalView?.classList.add('active');
            roomView?.classList.remove('active');
        } else {
            portalView?.classList.remove('active');
            roomView?.classList.add('active');
        }
    }

    /**
     * Join room by entering room code
     */
    joinRoomByCode() {
        const roomCodeInput = document.getElementById('room-code-input');
        const roomCode = roomCodeInput.value.trim().toUpperCase();
        
        if (roomCode) {
            this.joinExistingRoom(roomCode);
        } else {
            this.showError('Please enter a room code');
        }
    }

    /**
     * Join an existing room
     */
    async joinExistingRoom(roomCode, gameType = null) {
        try {
            // Don't set gameType yet - we'll get it from the server
            this.gameType = gameType; // May be null, will be set by server response
            this.sessionId = roomCode;
            this.showLoadingOverlay();
            this.stopActiveRoomsRefresh();
            
            // Update URL to include room code if not already there
            if (window.location.pathname !== \`/\${roomCode}\`) {
                window.history.pushState({roomCode: roomCode}, '', \`/\${roomCode}\`);
            }
            
            await this.connectToGame();
        } catch (error) {
            console.error('Failed to join room:', error);
            this.showError('Failed to join room: ' + error.message);
            this.hideLoadingOverlay();
        }
    }

    /**
     * Format room code input
     */
    formatRoomCodeInput(e) {
        let value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
        if (value.length > 6) {
            value = value.substring(0, 6);
        }
        e.target.value = value;
    }

    /**
     * Handle WebSocket close
     */
    handleWebSocketClose() {
        this.isConnected = false;
        this.ws = null;
        
        // Don't automatically return to portal on unexpected disconnections
        // Only do this if we're intentionally leaving (sessionId is cleared)
        if (!this.sessionId) {
            this.currentView = 'portal';
            this.updateView();
        } else {
            // Keep the room view active even without connection
            // This allows users to see the room state even if connection drops
        }
    }

    /**
     * Handle player update messages
     */
    handlePlayerUpdate(message) {
        if (message.gameState) {
            this.players = message.gameState.players || {};
            
            // Update currentPlayer if it's the current player who was updated
            if (this.currentPlayerId && this.players[this.currentPlayerId]) {
                this.currentPlayer = this.players[this.currentPlayerId];
            }
            
            // Update players in the game module too
            if (this.gameModule) {
                this.gameModule.updatePlayers(this.players);
            }
            
            this.updatePlayersList();
            this.updateCurrentPlayerInfo();
        }
    }

    /**
     * Handle incoming chat message
     */
    handleChatMessage(message) {
        if (message.data) {
            this.addChatMessage(message.data);
        }
    }
    
    /**
     * Handle chat history
     */
    handleChatHistory(message) {
        if (message.data && message.data.messages) {
            // Clear placeholder messages
            const chatMessagesEl = document.getElementById('chat-messages');
            if (chatMessagesEl) {
                chatMessagesEl.innerHTML = '';
            }
            
            // Add historical messages
            message.data.messages.forEach(msg => {
                this.addChatMessage(msg, false);
            });
        }
    }
    
    /**
     * Add a chat message to the UI
     */
    addChatMessage(messageData, scrollToBottom = true) {
        const chatMessagesEl = document.getElementById('chat-messages');
        if (!chatMessagesEl) return;
        
        // Create a wrapper for messages if it doesn't exist
        let messagesWrapper = chatMessagesEl.querySelector('.chat-messages-wrapper');
        if (!messagesWrapper) {
            messagesWrapper = document.createElement('div');
            messagesWrapper.className = 'chat-messages-wrapper';
            chatMessagesEl.appendChild(messagesWrapper);
        }
        
        const messageEl = document.createElement('div');
        messageEl.className = 'chat-message';
        
        const authorEl = document.createElement('span');
        authorEl.className = 'chat-author';
        authorEl.textContent = \`\${messageData.playerEmoji} \${messageData.playerName}\${messageData.isSpectator ? ' (spectator)' : ''}:\`;
        
        const textEl = document.createElement('span');
        textEl.className = 'chat-text';
        textEl.textContent = messageData.message;
        
        messageEl.appendChild(authorEl);
        messageEl.appendChild(textEl);
        
        messagesWrapper.appendChild(messageEl);
        
        // Store message
        this.chatMessages.push(messageData);
        
        // Scroll to bottom if requested
        if (scrollToBottom) {
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }
    }
    
    /**
     * Handle spectator update messages
     */
    handleSpectatorUpdate(message) {
        if (message.type === 'spectator_identity') {
            this.isSpectator = true;
            this.spectatorId = message.data.spectatorId;
            
            // CRITICAL: Ensure view stays on room for spectators
            this.currentView = 'room';
            
            // Update UI to show spectator mode
            this.showSpectatorUI();
            this.updateView();
            this.hideLoadingOverlay();
        }
        
        if (message.data && message.data.spectators) {
            this.spectators = message.data.spectators;
            this.updateSpectatorsDisplay();
            this.updateChatUsersList();
        }
        
        // Update game controls for spectator
        if (this.isSpectator) {
            this.updateGameControls();
        }
    }

    /**
     * Start game session (host only)
     */
    startGameSession() {
        if (this.ws && this.isConnected) {
            this.ws.send(JSON.stringify({
                type: 'START_GAME',
                data: { gameType: this.gameType }
            }));
        }
    }

    /**
     * Update player name
     */
    updatePlayerName(name) {
        if (this.ws && this.isConnected) {
            this.ws.send(JSON.stringify({
                type: 'change_name',
                data: { newName: name }
            }));
            
            // Immediately update local state and UI
            if (this.currentPlayer) {
                this.currentPlayer.name = name;
                if (this.players[this.currentPlayerId]) {
                    this.players[this.currentPlayerId].name = name;
                }
                this.updatePlayersList();
                this.updateCurrentPlayerInfo();
            }
        }
    }

    /**
     * Show emoji picker
     * 
     * CRITICAL: EMOJI PICKER POSITIONING (PROTECTED CODE - DO NOT MODIFY)
     * This method uses specific positioning logic to solve z-index stacking issues:
     * - Moves picker to document.body to escape parent container stacking contexts
     * - Uses setProperty with 'important' flag to override CSS conflicts
     * - Calculates position after showing picker for accurate getBoundingClientRect()
     * - Forces z-index: 999999 to appear above all UI elements
     * - Handles viewport boundaries to prevent picker from appearing off-screen
     * 
     * DO NOT MODIFY this positioning logic - it was extensively debugged to solve
     * emoji picker being hidden under UI elements or appearing in wrong position.
     */
    showEmojiPicker() {
        const picker = document.getElementById('emoji-picker');
        const emojiBtn = document.getElementById('current-emoji-btn');
        
        if (picker && emojiBtn) {
            if (picker.style.display === 'none' || picker.style.display === '') {
                // Initialize emoji grid first if needed
                const emojiGrid = document.getElementById('emoji-grid');
                if (emojiGrid && emojiGrid.children.length === 0) {
                    this.initializeEmojiGrid();
                }
                
                // CRITICAL: Move picker to body to escape parent container z-index issues
                if (picker.parentElement !== document.body) {
                    document.body.appendChild(picker);
                }
                
                // Show the picker first (required for accurate height calculation)
                picker.style.display = 'block';
                
                // CRITICAL: Force position: fixed for proper positioning
                picker.style.position = 'fixed';
                
                // Calculate position relative to the button
                const rect = emojiBtn.getBoundingClientRect();
                const pickerWidth = 340; // Width set in HTML
                const pickerHeight = picker.getBoundingClientRect().height;
                
                // Calculate horizontal position - center below button
                let left = rect.left + (rect.width / 2) - (pickerWidth / 2);
                
                // Keep within viewport bounds horizontally
                if (left < 10) left = 10;
                if (left + pickerWidth > window.innerWidth - 10) {
                    left = window.innerWidth - pickerWidth - 10;
                }
                
                // Calculate vertical position - prefer below button
                let top = rect.bottom + 5;
                
                // If picker would go off bottom of screen, show above button instead
                if (top + pickerHeight > window.innerHeight - 10) {
                    top = rect.top - pickerHeight - 5;
                    // Make sure it doesn't go off top of screen
                    if (top < 10) {
                        top = rect.bottom + 5; // Fall back to below if no room above
                    }
                }
                
                // CRITICAL: Apply positioning with !important to override any conflicting styles
                picker.style.setProperty('left', left + 'px', 'important');
                picker.style.setProperty('top', top + 'px', 'important');
                picker.style.setProperty('z-index', '999999', 'important');
            } else {
                picker.style.display = 'none';
            }
        }
    }

    /**
     * Initialize emoji picker grid
     */
    initializeEmojiGrid() {
        const emojiGrid = document.getElementById('emoji-grid');
        if (!emojiGrid) return;

        const animalEmojis = [
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', '',
            '', '', '', '', '', '', '', ''
        ];

        animalEmojis.forEach(emoji => {
            const emojiBtn = document.createElement('button');
            emojiBtn.textContent = emoji;
            emojiBtn.style.cssText = 'border: 1px solid transparent; background: white; font-size: 26px; cursor: pointer; padding: 8px; border-radius: 6px; transition: all 0.2s; aspect-ratio: 1;';
            emojiBtn.addEventListener('click', () => {
                this.selectEmoji(emoji);
            });
            emojiBtn.addEventListener('mouseover', () => {
                emojiBtn.style.background = '#e3f2fd';
                emojiBtn.style.borderColor = '#007bff';
                emojiBtn.style.transform = 'scale(1.1)';
            });
            emojiBtn.addEventListener('mouseout', () => {
                emojiBtn.style.background = 'white';
                emojiBtn.style.borderColor = 'transparent';
                emojiBtn.style.transform = 'scale(1)';
            });
            emojiGrid.appendChild(emojiBtn);
        });
    }

    /**
     * Select emoji
     */
    selectEmoji(emoji) {
        if (this.ws && this.isConnected) {
            this.ws.send(JSON.stringify({
                type: 'change_emoji',
                data: { newEmoji: emoji }
            }));
        }
        
        // Immediately update local state and UI
        if (this.currentPlayer) {
            this.currentPlayer.emoji = emoji;
            if (this.players[this.currentPlayerId]) {
                this.players[this.currentPlayerId].emoji = emoji;
            }
        }
        
        // Update button immediately for feedback
        const emojiBtn = document.getElementById('current-emoji-btn');
        if (emojiBtn) {
            emojiBtn.textContent = emoji;
        }
        
        // Update all UI elements with new emoji
        this.updatePlayersList();
        this.updateCurrentPlayerInfo();
        
        // Hide picker
        const picker = document.getElementById('emoji-picker');
        if (picker) {
            picker.style.display = 'none';
        }
    }

    /**
     * Update room info display
     */
    updateRoomInfo() {
        if (this.sessionId) {
            this.currentView = 'room';
            
            const gameTitle = document.getElementById('game-title');
            if (gameTitle) {
                gameTitle.textContent = this.formatGameName(this.gameType);
            }
            
            const roomCode = document.getElementById('room-code-display');
            if (roomCode) {
                roomCode.textContent = this.sessionId;
            }
        }
    }

    /**
     * Update players list display
     */
    updatePlayersList() {
        const container = document.getElementById('players-container');
        if (!container) return;

        container.innerHTML = '';

        Object.values(this.players).forEach(player => {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player-item';
            playerDiv.dataset.playerId = player.id;

            const isHost = this.roomState.hostId === player.id;
            const isCurrentPlayer = player.id === this.currentPlayerId;

            playerDiv.innerHTML = \`
                <span class="player-emoji">\${player.emoji}</span>
                <span class="player-name">\${player.name}</span>
                <span class="player-status">
                    \${isHost ? ' Host' : ''}
                    \${isCurrentPlayer ? '(You)' : ''}
                </span>
            \`;

            container.appendChild(playerDiv);
        });

        this.updateStartGameButton();
        this.updateCurrentPlayerInfo();
        this.updateChatUsersList();
    }

    /**
     * Update start game button state
     */
    updateStartGameButton() {
        const startButton = document.getElementById('start-game-btn-header');
        if (!startButton) return;

        const isHost = this.roomState.hostId === this.currentPlayerId;
        const gameNotStarted = this.gameState === 'waiting';

        if (isHost && gameNotStarted) {
            startButton.style.display = 'block';
            startButton.disabled = false;
        } else {
            startButton.style.display = 'none';
        }
    }

    /**
     * Update current player info displays
     */
    updateCurrentPlayerInfo() {
        if (!this.currentPlayer) return;

        const nameInput = document.getElementById('player-name-input');
        if (nameInput) {
            nameInput.value = this.currentPlayer.name;
        }

        const emojiBtn = document.getElementById('current-emoji-btn');
        if (emojiBtn) {
            emojiBtn.textContent = this.currentPlayer.emoji;
        }
    }

    /**
     * Update rules display based on game module
     */
    updateRulesDisplay() {
        const rulesBox = document.getElementById('rules-box');
        const rulesContent = document.getElementById('game-rules-content');
        
        if (this.gameModule && typeof this.gameModule.getRules === 'function') {
            const rules = this.gameModule.getRules();
            if (rules && rulesContent) {
                rulesContent.innerHTML = rules;
                if (rulesBox) {
                    rulesBox.style.display = 'block';
                }
            }
        } else if (rulesBox) {
            rulesBox.style.display = 'none';
        }
    }
    
    /**
     * Update game controls based on game state
     */
    updateGameControls() {
        const gameArea = document.getElementById('game-area');
        const chatArea = document.getElementById('chat-area');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const playerControls = document.getElementById('player-controls');
        const playersList = document.querySelector('.players-list');
        const waitingRoomContainer = document.querySelector('.waiting-room-container');

        // Special handling for spectators
        if (this.isSpectator) {
            // Always ensure spectator UI is visible
            this.showSpectatorUI();
            
            if (this.gameState === 'playing') {
                if (gameArea) gameArea.style.display = 'block';
                if (chatArea) {
                    chatArea.style.display = 'block'; // Show chat during game
                    // Enable chat for spectators too
                    if (chatInput) chatInput.disabled = false;
                    if (chatSendBtn) chatSendBtn.disabled = false;
                }
                if (playerControls) playerControls.style.display = 'none'; // Spectators can't control
                if (playersList) playersList.style.display = 'none'; // Hide during gameplay
                if (waitingRoomContainer) waitingRoomContainer.style.display = 'none'; // Hide waiting room container
            } else {
                if (gameArea) gameArea.style.display = 'none';
                if (chatArea) {
                    chatArea.style.display = 'none'; // Hide chat when not playing
                    if (chatInput) chatInput.disabled = true;
                    if (chatSendBtn) chatSendBtn.disabled = true;
                }
                if (playerControls) playerControls.style.display = 'none'; // Spectators can't control
                if (playersList) playersList.style.display = 'block'; // Show player list
                if (waitingRoomContainer) waitingRoomContainer.style.display = 'flex'; // Show waiting room container
            }
            return;
        }

        // Normal player controls
        if (this.gameState === 'playing') {
            if (gameArea) gameArea.style.display = 'block';
            if (chatArea) {
                chatArea.style.display = 'block'; // Show chat during game
                // Enable chat for players
                if (chatInput) chatInput.disabled = false;
                if (chatSendBtn) chatSendBtn.disabled = false;
            }
            if (playerControls) playerControls.style.display = 'none'; // Hide during gameplay
            if (playersList) playersList.style.display = 'none'; // Hide during gameplay
            if (waitingRoomContainer) waitingRoomContainer.style.display = 'none'; // Hide waiting room container
        } else if (this.gameState === 'finished') {
            if (gameArea) gameArea.style.display = 'block'; // Keep game visible for end screen
            if (chatArea) {
                chatArea.style.display = 'block'; // Keep chat visible at game end
                // Keep chat enabled at game end
                if (chatInput) chatInput.disabled = false;
                if (chatSendBtn) chatSendBtn.disabled = false;
            }
            if (playerControls) playerControls.style.display = 'none'; 
            if (playersList) playersList.style.display = 'none';
            if (waitingRoomContainer) waitingRoomContainer.style.display = 'none'; // Hide waiting room container
        } else if (this.gameState === 'waiting') {
            if (gameArea) gameArea.style.display = 'none';
            if (chatArea) {
                chatArea.style.display = 'block'; // Show chat in waiting room
                // Enable chat for waiting room
                if (chatInput) chatInput.disabled = false;
                if (chatSendBtn) chatSendBtn.disabled = false;
            }
            if (playerControls) playerControls.style.display = 'block';
            if (playersList) playersList.style.display = 'block';
            if (waitingRoomContainer) waitingRoomContainer.style.display = 'flex'; // Show waiting room container
        }
    }

    /**
     * Show spectator UI
     */
    showSpectatorUI() {
        // Add spectator indicator if not already present
        let spectatorIndicator = document.getElementById('spectator-indicator');
        if (!spectatorIndicator) {
            spectatorIndicator = document.createElement('div');
            spectatorIndicator.id = 'spectator-indicator';
            spectatorIndicator.className = 'spectator-indicator';
            spectatorIndicator.innerHTML = ' you are a spectator. enjoy the show ';
            spectatorIndicator.style.cssText = \`
                background: #17a2b8;
                color: white;
                padding: 8px 16px;
                border-radius: 6px;
                font-weight: bold;
                margin: 10px 0;
                text-align: center;
                position: sticky;
                top: 0;
                z-index: 10000;
            \`;
            
            // Insert after room-header instead of inside room-info
            const roomHeader = document.querySelector('.room-header');
            if (roomHeader && roomHeader.parentNode) {
                roomHeader.parentNode.insertBefore(spectatorIndicator, roomHeader.nextSibling);
            }
        }
        
        // Make sure it stays visible even when game area is shown
        const indicator = document.getElementById('spectator-indicator');
        if (indicator) {
            indicator.style.display = 'block';
        }
    }

    /**
     * Update the chat users list with players and spectators
     */
    updateChatUsersList() {
        const chatUsersList = document.getElementById('chat-users-list');
        if (!chatUsersList) return;
        
        chatUsersList.innerHTML = '';
        
        // Add players section if there are any players
        if (Object.keys(this.players).length > 0) {
            const playersSection = document.createElement('div');
            playersSection.className = 'chat-users-section';
            
            const playersHeader = document.createElement('div');
            playersHeader.className = 'chat-users-header';
            playersHeader.textContent = \`Players (\${Object.keys(this.players).length})\`;
            playersSection.appendChild(playersHeader);
            
            Object.values(this.players).forEach(player => {
                const userItem = document.createElement('div');
                userItem.className = 'chat-user-item';
                
                const isHost = this.roomState.hostId === player.id;
                const isCurrentPlayer = player.id === this.currentPlayerId;
                
                userItem.innerHTML = \`
                    <span class="chat-user-emoji">\${player.emoji}</span>
                    <span class="chat-user-name">\${player.name}\${isCurrentPlayer ? ' (you!)' : ''}</span>
                    \${isHost ? '<span class="chat-user-badge"></span>' : ''}
                \`;
                
                playersSection.appendChild(userItem);
            });
            
            chatUsersList.appendChild(playersSection);
        }
        
        // Add spectators section if there are any spectators
        if (Object.keys(this.spectators).length > 0) {
            const spectatorsSection = document.createElement('div');
            spectatorsSection.className = 'chat-users-section';
            
            const spectatorsHeader = document.createElement('div');
            spectatorsHeader.className = 'chat-users-header';
            spectatorsHeader.textContent = \`Spectators (\${Object.keys(this.spectators).length})\`;
            spectatorsSection.appendChild(spectatorsHeader);
            
            Object.values(this.spectators).forEach(spectator => {
                const userItem = document.createElement('div');
                userItem.className = 'chat-user-item spectator';
                
                const isCurrentSpectator = spectator.id === this.spectatorId;
                
                userItem.innerHTML = \`
                    <span class="chat-user-emoji">\${spectator.emoji}</span>
                    <span class="chat-user-name">\${spectator.name}\${isCurrentSpectator ? ' (you!)' : ''}</span>
                \`;
                
                spectatorsSection.appendChild(userItem);
            });
            
            chatUsersList.appendChild(spectatorsSection);
        }
    }

    /**
     * Update spectators display
     */
    updateSpectatorsDisplay() {
        const spectatorCount = Object.keys(this.spectators).length;
        if (spectatorCount > 0) {
            // Show spectator count somewhere in UI
        }
        // Update the chat users list to show spectators
        this.updateChatUsersList();
    }

    /**
     * Show game end screen
     */
    showGameEndScreen(gameEndData) {
        console.log('[GameShell] showGameEndScreen called');
        const endScreen = document.getElementById('end-game-screen');
        const resultMessage = document.getElementById('game-result-message');
        const finalScores = document.getElementById('final-scores');
        
        console.log('[GameShell] Elements:', { endScreen: !!endScreen, resultMessage: !!resultMessage, finalScores: !!finalScores });
        
        if (endScreen && resultMessage) {
            // Update message with server's result message
            resultMessage.textContent = gameEndData.message || 'Game Complete!';
            
            // Show final scores - server sends 'scores', not 'finalScores'
            if (finalScores) {
                const scores = gameEndData.scores || gameEndData.finalScores;
                if (scores && Object.keys(scores).length > 0) {
                    // Show scores when they exist - restore normal styling
                    finalScores.innerHTML = '';
                    finalScores.style.display = 'block';
                    finalScores.style.visibility = 'visible';
                    finalScores.style.height = '';
                    finalScores.style.padding = '';
                    finalScores.style.margin = '';
                    finalScores.style.border = '';
                    
                    Object.entries(scores).forEach(([playerId, score]) => {
                        const player = this.players[playerId];
                        if (player) {
                            const scoreItem = document.createElement('div');
                            scoreItem.className = 'final-score-item';
                            scoreItem.innerHTML = \`\${player.emoji} \${player.name}: \${score}\`;
                            finalScores.appendChild(scoreItem);
                        }
                    });
                } else {
                    // Hide the scores element when there are no scores
                    finalScores.style.display = 'none';
                }
            }
            
            console.log('[GameShell] Setting endScreen.style.display = block');
            endScreen.style.display = 'block';
            
            // Handle OK button - return to lobby
            const okBtn = document.getElementById('ok-btn');
            if (okBtn) {
                okBtn.onclick = () => {
                    endScreen.style.display = 'none';
                    // Return to lobby/portal
                    this.leaveGame();
                };
            }
        } else {
            console.error('[GameShell] Cannot show end screen - missing elements:', {
                endScreen: !!endScreen,
                resultMessage: !!resultMessage
            });
        }
    }

    /**
     * Leave game and return to portal
     */
    leaveGame() {
        if (this.ws) {
            this.ws.close();
        }
        
        // Clean up game module
        if (this.gameModule) {
            this.gameModule.cleanup();
            this.gameModule = null;
        }
        
        // Reset all state
        this.currentPlayerId = null;
        this.currentPlayer = null;
        this.players = {};
        this.sessionId = '';
        this.gameType = '';
        this.gameState = 'waiting';
        this.roomState = {};
        this.isSpectator = false;
        this.spectatorId = null;
        this.spectators = {};
        
        // Clean up UI
        this.cleanupGameUI();
        
        // Restore root URL
        window.history.pushState({}, '', '/');
        
        // Return to portal
        this.currentView = 'portal';
        this.updateView();
        this.loadActiveRooms();
        this.startActiveRoomsRefresh();
    }

    /**
     * Clean up game-specific UI elements
     */
    cleanupGameUI() {
        // Hide game area
        const gameArea = document.getElementById('game-area');
        if (gameArea) {
            gameArea.style.display = 'none';
            gameArea.innerHTML = '';
        }
        
        // Hide rules box
        const rulesBox = document.getElementById('rules-box');
        if (rulesBox) {
            rulesBox.style.display = 'none';
        }
        const rulesContent = document.getElementById('game-rules-content');
        if (rulesContent) {
            rulesContent.innerHTML = '';
        }
        
        // Hide and reset chat area
        const chatArea = document.getElementById('chat-area');
        if (chatArea) {
            chatArea.style.display = 'none';
        }
        const chatMessages = document.getElementById('chat-messages');
        if (chatMessages) {
            chatMessages.innerHTML = '';
        }
        const chatInput = document.getElementById('chat-input');
        if (chatInput) {
            chatInput.value = '';
            chatInput.disabled = true;
        }
        const chatSendBtn = document.getElementById('chat-send-btn');
        if (chatSendBtn) {
            chatSendBtn.disabled = true;
        }
        this.chatMessages = [];
        
        // Hide end game screen
        const endScreen = document.getElementById('end-game-screen');
        if (endScreen) endScreen.style.display = 'none';
        
        // Remove spectator indicator
        const spectatorIndicator = document.getElementById('spectator-indicator');
        if (spectatorIndicator) spectatorIndicator.remove();
        
        // Clear players
        const playersContainer = document.getElementById('players-container');
        if (playersContainer) playersContainer.innerHTML = '';
        
        // Clear name input
        const nameInput = document.getElementById('player-name-input');
        if (nameInput) nameInput.value = '';
        
        // Remove floating emojis
        document.querySelectorAll('.floating-emoji').forEach(el => el.remove());
    }

    /**
     * Load active rooms (placeholder - integrate with existing logic)
     */
    loadActiveRooms() {
        // This will integrate with the existing active rooms logic
    }

    /**
     * Start/stop active rooms refresh
     */
    startActiveRoomsRefresh() {
        // Integrate with existing refresh logic
    }

    stopActiveRoomsRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
    }

    /**
     * Format game name for display
     */
    formatGameName(gameType) {
        // Special cases for specific games
        const gameNames = {
            'checkbox-game': 'Checkbox Game',
            'votes-game': 'Everybody Votes',
            'county-game': 'County Game',
            'paddlin-game': "That's a Paddlin'",
            'price-game': 'The Price is Weird'
        };
        
        return gameNames[gameType] || gameType
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    /**
     * Utility: Generate session ID
     */
    generateSessionId() {
        return Math.random().toString(36).substr(2, 6).toUpperCase();
    }

    /**
     * Utility: Show error message
     */
    showError(message) {
        console.error(message);
        // TODO: Implement proper error UI
    }

    /**
     * Utility: Show/hide loading overlay
     */
    showLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) overlay.style.display = 'flex';
    }

    hideLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) overlay.style.display = 'none';
    }
}

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
    module.exports = GameShell;
} else {
    window.GameShell = GameShell;
}`,
  '/static/js/games/CheckboxGameModule.js': `/**
 * CheckboxGameModule - Implements the checkbox game as a GameModule
 * Manages a 3x3 grid of checkboxes where players collaborate to check all boxes
 */
class CheckboxGameModule extends GameModule {
    constructor() {
        super();
        this.checkboxStates = new Array(9).fill(false); // 3x3 grid
        this.checkboxPlayers = {}; // Track which player checked each box
        this.playerScores = {}; // Track player scores
    }

    /**
     * Initialize the checkbox game
     */
    init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement) {
        super.init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement);
        
        // Initialize game state
        if (initialState) {
            this.checkboxStates = initialState.checkboxStates || new Array(9).fill(false);
            this.checkboxPlayers = initialState.checkboxPlayers || {};
            this.playerScores = initialState.playerScores || {};
        }
        
        this.render();
    }

    /**
     * Handle state updates from server
     */
    handleStateUpdate(gameSpecificState) {
        super.handleStateUpdate(gameSpecificState);
        
        
        if (gameSpecificState.checkboxStates) {
            this.checkboxStates = gameSpecificState.checkboxStates;
        }
        if (gameSpecificState.checkboxPlayers) {
            this.checkboxPlayers = gameSpecificState.checkboxPlayers;
        }
        if (gameSpecificState.playerScores) {
            this.playerScores = gameSpecificState.playerScores;
        }
        // Update players if included in the gameSpecificState
        if (gameSpecificState.players) {
            this.players = gameSpecificState.players;
        }
        
        
        this.render();
    }

    /**
     * Handle player actions from WebSocket messages
     */
    handlePlayerAction(playerId, action) {
        switch (action.type) {
            case 'checkbox_toggled':
                if (action.data) {
                    const { checkboxIndex, newState } = action.data;
                    this.checkboxStates[checkboxIndex] = newState;
                    if (newState) {
                        this.checkboxPlayers[checkboxIndex] = playerId;
                    } else {
                        delete this.checkboxPlayers[checkboxIndex];
                    }
                    this.updateCheckboxUI(checkboxIndex, newState, playerId);
                    this.updateScoreboard();
                }
                break;
        }
    }

    /**
     * Get game rules HTML
     */
    getRules() {
        return \`
            <ul>
                <li>Click the boxes</li>
                <li>It's not much of a game, is it</li>
            </ul>
        \`;
    }
    
    /**
     * Check win condition - all checkboxes must be checked
     */
    getWinCondition() {
        const allChecked = this.checkboxStates.every(state => state === true);
        if (allChecked) {
            // Calculate final scores
            const finalScores = {};
            Object.values(this.players).forEach(player => {
                finalScores[player.id] = this.getPlayerScore(player.id);
            });
            
            // Find winner (player with most checkboxes)
            let winnerId = null;
            let maxScore = -1;
            Object.entries(finalScores).forEach(([playerId, score]) => {
                if (score > maxScore) {
                    maxScore = score;
                    winnerId = playerId;
                }
            });

            return {
                winnerId,
                points: finalScores
            };
        }
        return null;
    }

    /**
     * Render the checkbox game UI
     */
    render() {
        if (!this.gameAreaElement) return;

        this.gameAreaElement.innerHTML = \`
            <div class="checkbox-game-container">
                
                <div class="game-layout">
                    <!-- Scoreboard on the left -->
                    <div id="scoreboard" class="scoreboard">
                        <h4>Scoreboard</h4>
                        <div id="score-list" class="score-list">
                            <!-- Scores will be populated -->
                        </div>
                    </div>
                    
                    <!-- Checkbox grid in the center -->
                    <div id="checkbox-grid" class="checkbox-grid">
                        <!-- 3x3 checkbox grid will be generated -->
                    </div>
                </div>
            </div>
        \`;

        this.initializeCheckboxGrid();
        this.updateScoreboard();
    }

    /**
     * Initialize the 3x3 checkbox grid
     */
    initializeCheckboxGrid() {
        const checkboxGrid = this.gameAreaElement.querySelector('#checkbox-grid');
        if (!checkboxGrid) {
            console.error('Checkbox grid element not found!');
            return;
        }

        // Clear any existing content
        checkboxGrid.innerHTML = '';
        
        // Create 3x3 grid of checkboxes (9 total)
        for (let i = 0; i < 9; i++) {
            const checkboxItem = document.createElement('div');
            checkboxItem.className = 'checkbox-item';
            checkboxItem.dataset.index = i;
            
            const checkboxIcon = document.createElement('span');
            checkboxIcon.className = 'checkbox-icon';
            
            // Determine the icon to show (player emoji or checkmark)
            if (this.checkboxStates[i]) {
                const playerId = this.checkboxPlayers[i];
                if (playerId && this.players[playerId]) {
                    const player = this.players[playerId];
                    checkboxIcon.textContent = player.emoji || '';
                } else {
                    checkboxIcon.textContent = '';
                }
            } else {
                checkboxIcon.textContent = '';
            }
            
            checkboxItem.appendChild(checkboxIcon);
            
            // Add click handler
            checkboxItem.addEventListener('click', () => {
                this.toggleCheckbox(i);
            });
            
            checkboxGrid.appendChild(checkboxItem);
            
            // Update visual state
            if (this.checkboxStates[i]) {
                checkboxItem.classList.add('checked');
            }
        }
    }

    /**
     * Toggle a checkbox (send action to server)
     */
    toggleCheckbox(checkboxIndex) {
        // Prevent spectators from taking actions
        if (this.isSpectator) {
            this.showError?.('Spectators cannot interact with the game');
            return;
        }

        if (this.onPlayerAction) {
            // Add visual feedback
            const checkboxItem = this.gameAreaElement.querySelector(\`.checkbox-item[data-index="\${checkboxIndex}"]\`);
            if (checkboxItem) {
                checkboxItem.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    checkboxItem.style.transform = '';
                }, 150);
            }
            
            // Send toggle action to server via shell
            this.onPlayerAction({
                type: 'toggle_checkbox',
                data: { checkboxIndex: checkboxIndex }
            });
        }
    }

    /**
     * Update the UI for a specific checkbox
     */
    updateCheckboxUI(checkboxIndex, newState, playerId = null) {
        const checkboxItem = this.gameAreaElement.querySelector(\`.checkbox-item[data-index="\${checkboxIndex}"]\`);
        if (!checkboxItem) return;
        
        const checkboxIcon = checkboxItem.querySelector('.checkbox-icon');
        if (!checkboxIcon) return;
        
        if (newState) {
            checkboxItem.classList.add('checked');
            
            
            // Show the player's emoji if we know who checked it
            if (playerId && this.players[playerId]) {
                const player = this.players[playerId];
                checkboxIcon.textContent = player.emoji || '';
            } else {
                checkboxIcon.textContent = '';
            }
        } else {
            checkboxItem.classList.remove('checked');
            checkboxIcon.textContent = '';
        }
    }

    /**
     * Update the scoreboard display
     */
    updateScoreboard() {
        const scoreList = this.gameAreaElement.querySelector('#score-list');
        if (!scoreList) return;
        
        scoreList.innerHTML = '';
        
        // Sort players by score (descending)
        const sortedPlayers = Object.values(this.players)
            .filter(player => !player.isSpectator)
            .sort((a, b) => this.getPlayerScore(b.id) - this.getPlayerScore(a.id));
        
        sortedPlayers.forEach(player => {
            const score = this.getPlayerScore(player.id);
            const scoreItem = document.createElement('div');
            scoreItem.className = 'score-item';
            scoreItem.innerHTML = \`
                <span class="score-player">\${player.emoji} \${player.name}</span>
                <span class="score-points">\${score}</span>
            \`;
            scoreList.appendChild(scoreItem);
        });
    }

    /**
     * Get score for a specific player
     */
    getPlayerScore(playerId) {
        let score = 0;
        for (let i = 0; i < this.checkboxStates.length; i++) {
            if (this.checkboxStates[i] && this.checkboxPlayers[i] === playerId) {
                score++;
            }
        }
        return score;
    }

    /**
     * Game-specific methods
     */
    getDisplayName() {
        return 'Checkbox Game';
    }

    getGameType() {
        return 'checkbox-game';
    }

    /**
     * Clean up checkbox game resources
     */
    cleanup() {
        this.checkboxStates = new Array(9).fill(false);
        this.checkboxPlayers = {};
        this.playerScores = {};
        super.cleanup();
    }
}

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CheckboxGameModule;
} else {
    window.CheckboxGameModule = CheckboxGameModule;
}`,
  '/static/js/games/CountyGameModule.js': `/**
 * CountyGameModule
 * A silly game where players submit county names and celebrate together
 */
class CountyGameModule extends GameModule {
    constructor() {
        super();
        this.currentPhase = 'WAITING'; // WAITING, COUNTY_SUBMISSION, COUNTY_ANNOUNCEMENT, GAME_OVER
        this.myCounty = null;
        this.submittedCount = 0;
        this.totalPlayers = 0;
        this.timeRemaining = 0;
        this.timerInterval = null;
        this.counties = {};
        this.currentAnnouncement = null;
        this.canConclude = false;
        this.isHost = false;
    }

    /**
     * Initialize the game
     */
    init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement) {
        super.init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement);
        
        // Check if current player is host
        if (initialState && initialState.hostId) {
            this.isHost = (this.currentPlayerId === initialState.hostId);
        }
        
        // Set initial state if provided
        if (initialState) {
            this.currentPhase = initialState.phase || 'WAITING';
            this.counties = initialState.counties || {};
            this.timeRemaining = initialState.timeLimit || 30;
            
            // Calculate time remaining from server end time
            if (initialState.submissionEndTime) {
                const now = Date.now();
                this.timeRemaining = Math.max(0, Math.floor((initialState.submissionEndTime - now) / 1000));
            }
        }
        
        this.totalPlayers = Object.keys(this.players).length;
        this.render();
    }

    /**
     * Get game rules HTML
     */
    getRules() {
        return \`
            <h3>County Game</h3>
            <ul>
                <li>enter the name of a county</li>
                <li>everybody wins!</li>
            </ul>
        \`;
    }

    /**
     * Start countdown timer
     */
    startTimer() {
        this.clearTimer();
        this.timerInterval = setInterval(() => {
            this.timeRemaining = Math.max(0, this.timeRemaining - 1);
            this.updateTimerDisplay();
            if (this.timeRemaining <= 0) {
                this.clearTimer();
            }
        }, 1000);
    }

    /**
     * Clear countdown timer
     */
    clearTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    /**
     * Update timer display
     */
    updateTimerDisplay() {
        const timerElement = this.gameAreaElement?.querySelector('.timer-display');
        if (timerElement) {
            timerElement.textContent = \`Time remaining: \${this.timeRemaining}s\`;
        }
    }

    /**
     * Update submission status without re-rendering the entire UI
     */
    updateSubmissionStatus() {
        // Update all submission status elements (both in form and in submitted view)
        const statusElements = this.gameAreaElement?.querySelectorAll('.submission-status');
        if (statusElements) {
            statusElements.forEach(element => {
                element.textContent = \`\${this.submittedCount} of \${this.totalPlayers} players submitted\`;
            });
        }
    }

    /**
     * Render the game UI based on current phase
     */
    render() {
        if (!this.gameAreaElement) return;
        
        // Preserve current input value if it exists
        const existingInput = this.gameAreaElement.querySelector('#county-input');
        const preservedValue = existingInput ? existingInput.value : '';
        
        let content = '';
        
        switch (this.currentPhase) {
            case 'WAITING':
                content = this.renderWaitingPhase();
                break;
            case 'COUNTY_SUBMISSION':
                content = this.renderSubmissionPhase();
                break;
            case 'COUNTY_ANNOUNCEMENT':
                content = this.renderAnnouncementPhase();
                break;
            case 'GAME_OVER':
                // Game over is handled by the shell's win screen
                content = '';
                break;
            default:
                content = this.renderWaitingPhase();
        }
        
        this.gameAreaElement.innerHTML = content;
        
        // Restore input value if we're still in submission phase and haven't submitted yet
        if (this.currentPhase === 'COUNTY_SUBMISSION' && !this.myCounty && preservedValue) {
            const newInput = this.gameAreaElement.querySelector('#county-input');
            if (newInput) {
                newInput.value = preservedValue;
            }
        }
        
        this.attachEventListeners();
    }

    /**
     * Render waiting phase
     */
    renderWaitingPhase() {
        return \`
            <div class="county-game-waiting">
                <h2>County Game</h2>
                <p>Waiting for the host to start the game...</p>
                <p>Get ready to share your county!</p>
            </div>
        \`;
    }

    /**
     * Render submission phase
     */
    renderSubmissionPhase() {
        const hasSubmitted = this.myCounty !== null;
        
        return \`
            <div class="county-game-submission">
                <h2>Submit Your County!</h2>
                <div class="timer-display">Time remaining: \${this.timeRemaining}s</div>
                
                \${hasSubmitted ? \`
                    <div class="submission-complete">
                        <p> County submitted!</p>
                        <p class="submitted-county">You submitted: <strong>\${this.myCounty}</strong></p>
                        <p>Waiting for others...</p>
                        <div class="submission-status">
                            \${this.submittedCount} of \${this.totalPlayers} players submitted
                        </div>
                    </div>
                \` : \`
                    <div class="submission-form">
                        <p>Enter a county name (where you're from, where you live, or any county!):</p>
                        <input 
                            type="text" 
                            id="county-input" 
                            placeholder="Enter a county name..." 
                            maxlength="100"
                            autocomplete="off"
                        />
                        <button id="submit-county-btn" class="submit-btn">Submit County</button>
                        <div class="submission-status">
                            \${this.submittedCount} of \${this.totalPlayers} players submitted
                        </div>
                    </div>
                \`}
            </div>
        \`;
    }

    /**
     * Render announcement phase
     */
    renderAnnouncementPhase() {
        let content = \`
            <div class="county-game-announcement">
                <h2>County Announcements</h2>
        \`;

        if (this.currentAnnouncement) {
            content += \`
                <div class="announcement-display">
                    <div class="player-number">PLAYER \${this.currentAnnouncement.playerNumber}</div>
                    <div class="player-info">
                        <span class="player-emoji">\${this.currentAnnouncement.playerEmoji}</span>
                        <span class="player-name">\${this.currentAnnouncement.playerName}</span>
                    </div>
                    <div class="county-name">"\${this.currentAnnouncement.county}"</div>
                </div>
            \`;
        } else {
            // Show different message for host vs other players
            if (this.isHost) {
                content += \`
                    <div class="announcement-waiting">
                        <p>Click BEGIN to start the excitement!</p>
                    </div>
                \`;
            } else {
                content += \`
                    <div class="announcement-waiting">
                        <p>Waiting for host to begin announcements...</p>
                    </div>
                \`;
            }
        }

        // Show controls for host
        if (this.isHost) {
            content += '<div class="host-controls">';
            
            if (!this.currentAnnouncement) {
                content += '<button id="begin-btn" class="control-btn">BEGIN</button>';
            } else if (this.canConclude) {
                content += '<button id="conclude-btn" class="control-btn">CONCLUDE</button>';
            } else if (!this.currentAnnouncement.isLast) {
                content += '<button id="next-btn" class="control-btn">NEXT</button>';
            } else {
                content += '<p>All players announced!</p>';
                content += '<button id="conclude-btn" class="control-btn">CONCLUDE</button>';
            }
            
            content += '</div>';
        }

        content += '</div>';
        return content;
    }

    /**
     * Attach event listeners
     */
    attachEventListeners() {
        // Submit county button
        const submitBtn = this.gameAreaElement?.querySelector('#submit-county-btn');
        const countyInput = this.gameAreaElement?.querySelector('#county-input');
        
        if (submitBtn && countyInput) {
            submitBtn.addEventListener('click', () => this.submitCounty());
            countyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.submitCounty();
                }
            });
            
            // Focus the input
            countyInput.focus();
        }

        // Announcement phase buttons (host only)
        const beginBtn = this.gameAreaElement?.querySelector('#begin-btn');
        const nextBtn = this.gameAreaElement?.querySelector('#next-btn');
        const concludeBtn = this.gameAreaElement?.querySelector('#conclude-btn');

        if (beginBtn) {
            beginBtn.addEventListener('click', () => {
                if (this.onPlayerAction) {
                    this.onPlayerAction({
                        type: 'begin_announcements'
                    });
                }
            });
        }

        if (nextBtn) {
            nextBtn.addEventListener('click', () => {
                if (this.onPlayerAction) {
                    this.onPlayerAction({
                        type: 'next_announcement'
                    });
                }
            });
        }

        if (concludeBtn) {
            concludeBtn.addEventListener('click', () => {
                if (this.onPlayerAction) {
                    this.onPlayerAction({
                        type: 'conclude_announcements'
                    });
                }
            });
        }
    }

    /**
     * Submit county to server
     */
    submitCounty() {
        const countyInput = this.gameAreaElement?.querySelector('#county-input');
        if (!countyInput) return;
        
        const county = countyInput.value.trim();
        if (!county) {
            alert('Please enter a county name!');
            return;
        }
        
        // Send to server
        if (this.onPlayerAction) {
            this.onPlayerAction({
                type: 'submit_county',
                county: county
            });
        }
        
        // Store locally
        this.myCounty = county;
        this.render();
    }

    /**
     * Handle state updates from server
     */
    handleStateUpdate(gameSpecificState) {
        super.handleStateUpdate(gameSpecificState);
        
        // Track if phase changed to determine if we need to re-render
        const previousPhase = this.currentPhase;
        
        // Check if we have the full gameState to determine host
        if (gameSpecificState.hostId) {
            this.isHost = (this.currentPlayerId === gameSpecificState.hostId);
        }
        
        if (gameSpecificState.phase) {
            this.currentPhase = gameSpecificState.phase;
        }
        
        if (gameSpecificState.counties) {
            this.counties = gameSpecificState.counties;
        }
        
        if (gameSpecificState.submissionEndTime) {
            const now = Date.now();
            this.timeRemaining = Math.max(0, Math.floor((gameSpecificState.submissionEndTime - now) / 1000));
            
            if (this.currentPhase === 'COUNTY_SUBMISSION' && this.timeRemaining > 0) {
                this.startTimer();
            }
        }
        
        // Only render if phase changed or we're not in submission phase
        // This prevents re-rendering (and clearing inputs) during submission updates
        if (previousPhase !== this.currentPhase || this.currentPhase !== 'COUNTY_SUBMISSION') {
            this.render();
        }
    }

    /**
     * Handle messages from server
     */
    handleMessage(message) {
        switch (message.type) {
            case 'phase_changed':
                this.currentPhase = message.phase;
                if (message.phase === 'COUNTY_SUBMISSION') {
                    // Clear previous submission
                    this.myCounty = null;
                    this.submittedCount = 0;
                } else if (message.phase === 'COUNTY_ANNOUNCEMENT') {
                    // Reset announcement state
                    this.currentAnnouncement = null;
                    this.canConclude = false;
                }
                this.render();
                break;
                
            case 'county_submission_started':
                this.timeRemaining = message.timeLimit || 30;
                this.startTimer();
                this.render();
                break;
                
            case 'county_submitted':
                // Confirmation of our submission
                this.myCounty = message.county;
                this.render();
                break;
                
            case 'submission_update':
                this.submittedCount = message.submittedCount;
                this.totalPlayers = message.totalPlayers;
                // Only update the submission status display, don't re-render the whole UI
                this.updateSubmissionStatus();
                break;
                
            case 'player_announcement':
                // Display the current player's county
                this.currentAnnouncement = message.data;
                this.canConclude = false;
                this.render();
                break;
                
            case 'all_announced':
                // All players have been announced, can now conclude
                this.canConclude = true;
                this.render();
                break;
                
            case 'game_ended':
                // Game ended is handled by the shell - just cleanup
                this.clearTimer();
                break;
        }
    }

    /**
     * Cleanup when leaving game
     */
    cleanup() {
        this.clearTimer();
        super.cleanup();
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CountyGameModule;
} else {
    window.CountyGameModule = CountyGameModule;
}`,
  '/static/js/games/EverybodyVotesGameModule.js': `/**
 * EverybodyVotesGameModule - Multi-round implementation
 * Simple voting game: Pizza or Burgers? (and more!)
 */
class EverybodyVotesGameModule extends GameModule {
    constructor() {
        super();
        this.currentPhase = 'WAITING'; // WAITING, VOTING, PREDICTING, RESULTS, ENDED
        this.question = 'Pizza or Burgers?';
        this.options = ['Pizza', 'Burgers'];
        this.myVote = null;
        this.myPrediction = null;
        this.votesCount = 0;
        this.totalPlayers = 0;
        this.results = null;
        this.timeRemaining = 0;
        this.timerInterval = null;
        this.lastVoterName = null;
        this.allVoted = false;
        
        // Multi-round state
        this.currentRound = 1;
        this.totalRounds = 3;
        this.roundResults = [];
        this.playerScores = {};
        this.finalScores = [];
        this.isHost = false;
    }

    /**
     * Initialize the game
     */
    init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement) {
        super.init(gameAreaElement, players, initialState, onPlayerAction, onStateChange, rulesElement);
        
        console.log('EverybodyVotesGameModule.init() called with initialState:', initialState);
        
        // Set initial state if provided
        if (initialState) {
            this.currentPhase = initialState.phase || 'WAITING'; // Respect server phase
            this.question = initialState.question || 'Pizza or Burgers?';
            this.options = initialState.options || ['Pizza', 'Burgers'];
            this.results = initialState.results || null;
            
            // Multi-round state
            this.currentRound = initialState.currentRound || 1;
            this.totalRounds = initialState.totalRounds || 3;
            this.roundResults = initialState.roundResults || [];
            this.playerScores = initialState.playerScores || {};
            this.finalScores = initialState.finalScores || [];
            this.isHost = initialState.isHost || false;
            
            console.log(\`Initial phase: \${this.currentPhase}, question: \${this.question}, round: \${this.currentRound}/\${this.totalRounds}\`);
        } else {
            // Default to VOTING phase
            this.currentPhase = 'VOTING';
        }
        
        this.render();
    }

    /**
     * Get game rules HTML
     */
    getRules() {
        return \`
            <h3>Everybody Votes!</h3>
            <p><strong>Multi-round voting game with predictions!</strong></p>
            <ol>
                <li>Vote for your favorite option</li>
                <li>Predict what the majority will vote for</li>
                <li>Get points for correct predictions</li>
                <li>Play \${this.totalRounds} rounds total</li>
                <li>Player with most points wins!</li>
            </ol>
            <p><em>You have time limits for both voting and predicting!</em></p>
        \`;
    }

    /**
     * Start countdown timer
     */
    startTimer() {
        this.clearTimer();
        this.timerInterval = setInterval(() => {
            this.timeRemaining = Math.max(0, this.timeRemaining - 1);
            this.updateTimerDisplay();
            if (this.timeRemaining <= 0) {
                this.clearTimer();
            }
        }, 1000);
    }

    /**
     * Clear countdown timer
     */
    clearTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    /**
     * Update timer display
     */
    updateTimerDisplay() {
        const timerElement = this.gameAreaElement?.querySelector('.timer-display');
        if (timerElement) {
            timerElement.textContent = \`Time remaining: \${this.timeRemaining}s\`;
        }
    }

    /**
     * Render the game UI based on current phase
     */
    render() {
        if (!this.gameAreaElement) return;
        
        let content = '';
        
        switch (this.currentPhase) {
            case 'WAITING':
                content = this.renderWaitingPhase();
                break;
            case 'VOTING':
                content = this.renderVotingPhase();
                break;
            case 'PREDICTING':
                content = this.renderPredictingPhase();
                break;
            case 'RESULTS':
                content = this.renderResultsPhase();
                break;
            case 'ENDED':
                content = this.renderFinalResultsPhase();
                break;
            default:
                content = this.renderWaitingPhase();
        }
        
        this.gameAreaElement.innerHTML = content;
        this.attachEventListeners();
    }

    /**
     * Get round progress indicator HTML
     */
    getRoundProgressIndicator() {
        return \`
            <div style="
                background: rgba(255, 255, 255, 0.2);
                padding: 1rem;
                border-radius: 8px;
                margin-bottom: 1.5rem;
                text-align: center;
                backdrop-filter: blur(10px);
            ">
                <h3 style="margin: 0; font-size: 1.5rem; font-weight: bold;">
                    Round \${this.currentRound} of \${this.totalRounds}
                </h3>
                <div style="
                    display: flex;
                    justify-content: center;
                    gap: 0.5rem;
                    margin-top: 0.5rem;
                ">
                    \${Array.from({length: this.totalRounds}, (_, i) => {
                        const roundNum = i + 1;
                        const isActive = roundNum === this.currentRound;
                        const isCompleted = roundNum < this.currentRound;
                        return \`
                            <div style="
                                width: 20px;
                                height: 20px;
                                border-radius: 50%;
                                background: \${isCompleted ? '#4CAF50' : isActive ? '#FFF' : 'rgba(255,255,255,0.3)'};
                                color: \${isActive && !isCompleted ? '#667eea' : '#FFF'};
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 0.8rem;
                                font-weight: bold;
                                border: 2px solid \${isActive ? '#FFF' : 'transparent'};
                            ">
                                \${isCompleted ? '' : roundNum}
                            </div>
                        \`;
                    }).join('')}
                </div>
            </div>
        \`;
    }

    /**
     * Render waiting phase (shouldn't normally see this)
     */
    renderWaitingPhase() {
        return \`
            <div class="everybody-votes-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 400px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 12px;
                padding: 2rem;
                color: white;
                text-align: center;
            ">
                \${this.getRoundProgressIndicator()}
                <h2 style="font-size: 2rem; margin-bottom: 1rem;">Everybody Votes!</h2>
                <p style="font-size: 1.2rem;">Game is starting...</p>
            </div>
        \`;
    }

    /**
     * Render voting phase
     */
    renderVotingPhase() {
        console.log('Rendering voting phase...');
        
        return \`
            <div class="everybody-votes-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 2rem;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 12px;
                color: white;
            ">
                \${this.getRoundProgressIndicator()}
                <h2 style="font-size: 2rem; margin-bottom: 1rem;">Time to Vote!</h2>
                
                <div style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 1.5rem;
                    border-radius: 8px;
                    margin-bottom: 2rem;
                    backdrop-filter: blur(10px);
                ">
                    <h3 style="font-size: 1.8rem; margin: 0 0 1rem 0;">\${this.question}</h3>
                    \${this.votesCount > 0 ? \`
                        <div style="
                            background: rgba(255, 255, 255, 0.2);
                            padding: 1rem;
                            border-radius: 6px;
                            margin-top: 1rem;
                        ">
                            <p style="margin: 0; font-size: 1.2rem;">
                                 \${this.votesCount}/\${this.totalPlayers} players voted
                            </p>
                            \${this.lastVoterName ? \`
                                <p style="margin: 0.5rem 0 0 0; font-size: 1rem; opacity: 0.8;">
                                    Latest: \${this.lastVoterName}
                                </p>
                            \` : ''}
                            \${this.allVoted ? \`
                                <p style="margin: 0.5rem 0 0 0; font-size: 1rem; color: #4CAF50; font-weight: bold;">
                                    All players voted! Calculating results...
                                </p>
                            \` : ''}
                        </div>
                    \` : ''}
                </div>
                
                <div style="
                    display: flex;
                    gap: 2rem;
                    flex-wrap: wrap;
                    justify-content: center;
                ">
                    \${this.options.map((option, index) => {
                        const emojis = {
                            'Pizza': '',
                            'Burgers': '',
                            'Coffee': '',
                            'Tea': '',
                            'Beach': '',
                            'Mountains': ''
                        };
                        const emoji = emojis[option] || '';
                        const color = index === 0 ? '#667eea' : '#764ba2';
                        return \`
                            <button class="vote-btn" data-vote="\${option}" style="
                                background: white;
                                color: \${color};
                                border: none;
                                padding: 2rem 3rem;
                                font-size: 2rem;
                                font-weight: bold;
                                border-radius: 12px;
                                cursor: pointer;
                                transition: all 0.3s;
                                min-width: 200px;
                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                \${emoji} \${option}
                            </button>
                        \`;
                    }).join('')}
                </div>
            </div>
        \`;
    }

    /**
     * Render predicting phase
     */
    renderPredictingPhase() {
        console.log('Rendering predicting phase...');
        
        return \`
            <div class="everybody-votes-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 2rem;
                background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
                border-radius: 12px;
                color: white;
            ">
                \${this.getRoundProgressIndicator()}
                <h2 style="font-size: 2rem; margin-bottom: 1rem;"> Make Your Prediction!</h2>
                
                <div style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 1.5rem;
                    border-radius: 8px;
                    margin-bottom: 2rem;
                    backdrop-filter: blur(10px);
                ">
                    <h3 style="font-size: 1.8rem; margin: 0 0 1rem 0;">\${this.question}</h3>
                    <p style="font-size: 1.2rem; margin: 0;">
                        What do you think the majority voted for?
                    </p>
                    \${this.myVote ? \`
                        <div style="
                            background: rgba(255, 255, 255, 0.2);
                            padding: 1rem;
                            border-radius: 6px;
                            margin-top: 1rem;
                        ">
                            <p style="margin: 0; font-size: 1rem;">
                                Your vote: <strong>\${this.myVote}</strong>
                            </p>
                        </div>
                    \` : ''}
                </div>
                
                <div style="
                    display: flex;
                    gap: 2rem;
                    flex-wrap: wrap;
                    justify-content: center;
                ">
                    \${this.options.map((option, index) => {
                        const emojis = {
                            'Pizza': '',
                            'Burgers': '',
                            'Coffee': '',
                            'Tea': '',
                            'Beach': '',
                            'Mountains': ''
                        };
                        const emoji = emojis[option] || '';
                        const color = index === 0 ? '#ff6b6b' : '#ee5a24';
                        return \`
                            <button class="prediction-btn" data-prediction="\${option}" style="
                                background: white;
                                color: \${color};
                                border: none;
                                padding: 2rem 3rem;
                                font-size: 2rem;
                                font-weight: bold;
                                border-radius: 12px;
                                cursor: pointer;
                                transition: all 0.3s;
                                min-width: 200px;
                                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                \${emoji} \${option}
                            </button>
                        \`;
                    }).join('')}
                </div>
            </div>
        \`;
    }

    /**
     * Render results phase
     */
    renderResultsPhase() {
        console.log('Rendering results phase...');
        
        if (!this.results) {
            return \`<div class="everybody-votes-container">Loading results...</div>\`;
        }
        
        const option1Votes = this.results[this.options[0]] || 0;
        const option2Votes = this.results[this.options[1]] || 0;
        const totalVotes = this.results.totalVotes || 0;
        
        const option1Percentage = totalVotes > 0 ? Math.round((option1Votes / totalVotes) * 100) : 0;
        const option2Percentage = totalVotes > 0 ? Math.round((option2Votes / totalVotes) * 100) : 0;
        
        const winner = option1Votes > option2Votes ? this.options[0] : 
                      option2Votes > option1Votes ? this.options[1] : 'Tie';
        
        const emojis = {
            'Pizza': '',
            'Burgers': '',
            'Coffee': '',
            'Tea': '',
            'Beach': '',
            'Mountains': ''
        };
        
        const isLastRound = this.currentRound >= this.totalRounds;
        
        return \`
            <div class="everybody-votes-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 2rem;
                background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
                border-radius: 12px;
                color: white;
                text-align: center;
            ">
                \${this.getRoundProgressIndicator()}
                <h2 style="font-size: 2.5rem; margin-bottom: 1rem;"> Round \${this.currentRound} Results</h2>
                
                <div style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 1.5rem;
                    border-radius: 8px;
                    margin-bottom: 2rem;
                    backdrop-filter: blur(10px);
                    width: 100%;
                    max-width: 500px;
                ">
                    <h3 style="font-size: 1.8rem; margin: 0 0 1rem 0;">\${this.question}</h3>
                    
                    <div style="margin-bottom: 1rem;">
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 0.5rem;
                            padding: 1rem;
                            background: rgba(255, 255, 255, 0.2);
                            border-radius: 8px;
                            \${option1Votes >= option2Votes ? 'border: 3px solid #FFD700;' : ''}
                        ">
                            <span style="font-size: 1.5rem;">\${emojis[this.options[0]] || ''} \${this.options[0]}</span>
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <div style="
                                    background: #ff6b6b;
                                    height: 20px;
                                    border-radius: 10px;
                                    width: \${Math.max(5, option1Percentage * 2)}px;
                                    max-width: 200px;
                                    transition: width 0.3s ease;
                                "></div>
                                <span style="font-weight: bold; min-width: 60px;">\${option1Votes} (\${option1Percentage}%)</span>
                                \${option1Votes >= option2Votes && option1Votes !== option2Votes ? '<span style="font-size: 1.5rem;"></span>' : ''}
                            </div>
                        </div>
                        
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            padding: 1rem;
                            background: rgba(255, 255, 255, 0.2);
                            border-radius: 8px;
                            \${option2Votes >= option1Votes ? 'border: 3px solid #FFD700;' : ''}
                        ">
                            <span style="font-size: 1.5rem;">\${emojis[this.options[1]] || ''} \${this.options[1]}</span>
                            <div style="display: flex; align-items: center; gap: 1rem;">
                                <div style="
                                    background: #4ecdc4;
                                    height: 20px;
                                    border-radius: 10px;
                                    width: \${Math.max(5, option2Percentage * 2)}px;
                                    max-width: 200px;
                                    transition: width 0.3s ease;
                                "></div>
                                <span style="font-weight: bold; min-width: 60px;">\${option2Votes} (\${option2Percentage}%)</span>
                                \${option2Votes >= option1Votes && option1Votes !== option2Votes ? '<span style="font-size: 1.5rem;"></span>' : ''}
                            </div>
                        </div>
                    </div>
                    
                    <p style="font-size: 1.4rem; margin: 1rem 0; font-weight: bold;">
                        Winner: \${winner === 'Tie' ? 'It\\'s a tie!' : \`\${winner}\`}
                    </p>
                    
                    <p style="font-size: 1.2rem; margin: 1rem 0;">
                        Total votes: \${totalVotes}
                    </p>
                    
                    \${this.myPrediction ? \`
                        <div style="
                            background: rgba(255, 255, 255, 0.2);
                            padding: 1rem;
                            border-radius: 6px;
                            margin-top: 1rem;
                        ">
                            <p style="margin: 0; font-size: 1rem;">
                                Your prediction: <strong>\${this.myPrediction}</strong>
                                \${this.myPrediction === winner && winner !== 'Tie' ? ' Correct!' : ' Wrong'}
                            </p>
                        </div>
                    \` : ''}
                </div>
                
                \${isLastRound ? \`
                    <button id="end-game-btn" style="
                        background: #ff6b6b;
                        color: white;
                        border: none;
                        padding: 1rem 2rem;
                        font-size: 1.5rem;
                        font-weight: bold;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                        min-width: 200px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        margin-top: 1rem;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        End Game
                    </button>
                \` : (this.isHost ? \`
                    <button id="next-question-btn" style="
                        background: #FFD700;
                        color: #4CAF50;
                        border: none;
                        padding: 1rem 2rem;
                        font-size: 1.5rem;
                        font-weight: bold;
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.3s;
                        min-width: 200px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        margin-top: 1rem;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                         Next Question
                    </button>
                \` : \`
                    <p style="font-size: 1.2rem; margin: 1rem 0; opacity: 0.8;">
                        Waiting for host to continue...
                    </p>
                \`)}
            </div>
        \`;
    }

    /**
     * Render round transition phase
     */
    renderRoundTransitionPhase() {
        console.log('Rendering round transition phase...');
        
        // Get current scores display
        const scoresHtml = this.getPlayerScoresHtml();
        
        return \`
            <div class="everybody-votes-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 2rem;
                background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
                border-radius: 12px;
                color: white;
                text-align: center;
            ">
                \${this.getRoundProgressIndicator()}
                <h2 style="font-size: 2.5rem; margin-bottom: 1rem;">Round \${this.currentRound} Complete!</h2>
                
                <div style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 1.5rem;
                    border-radius: 8px;
                    margin-bottom: 2rem;
                    backdrop-filter: blur(10px);
                    width: 100%;
                    max-width: 600px;
                ">
                    <h3 style="font-size: 1.5rem; margin: 0 0 1rem 0;">Current Standings</h3>
                    \${scoresHtml}
                </div>
                
                \${this.isHost ? \`
                    <button id="continue-round-btn" style="
                        background: #FFD700;
                        color: #8e44ad;
                        border: none;
                        padding: 1.5rem 3rem;
                        font-size: 1.8rem;
                        font-weight: bold;
                        border-radius: 12px;
                        cursor: pointer;
                        transition: all 0.3s;
                        min-width: 250px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                         Continue to Next Round
                    </button>
                \` : \`
                    <p style="font-size: 1.2rem; margin: 1rem 0; opacity: 0.8;">
                        Waiting for host to continue...
                    </p>
                \`}
            </div>
        \`;
    }

    /**
     * Render final results phase
     */
    renderFinalResultsPhase() {
        console.log('Rendering final results phase...');
        
        const finalScoresHtml = this.getFinalScoresHtml();
        const roundSummaryHtml = this.getRoundSummaryHtml();
        
        return \`
            <div class="everybody-votes-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 2rem;
                background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
                border-radius: 12px;
                color: white;
                text-align: center;
            ">
                <h2 style="font-size: 3rem; margin-bottom: 1rem;">Game Complete!</h2>
                
                <div style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 1.5rem;
                    border-radius: 8px;
                    margin-bottom: 2rem;
                    backdrop-filter: blur(10px);
                    width: 100%;
                    max-width: 700px;
                ">
                    <h3 style="font-size: 2rem; margin: 0 0 1rem 0;"> Final Leaderboard</h3>
                    \${finalScoresHtml}
                </div>
                
                <div style="
                    background: rgba(255, 255, 255, 0.1);
                    padding: 1.5rem;
                    border-radius: 8px;
                    margin-bottom: 2rem;
                    backdrop-filter: blur(10px);
                    width: 100%;
                    max-width: 700px;
                ">
                    <h3 style="font-size: 1.5rem; margin: 0 0 1rem 0;"> Round Summary</h3>
                    \${roundSummaryHtml}
                </div>
                
                <button id="new-game-btn" style="
                    background: #FFD700;
                    color: #c0392b;
                    border: none;
                    padding: 1.5rem 3rem;
                    font-size: 1.8rem;
                    font-weight: bold;
                    border-radius: 12px;
                    cursor: pointer;
                    transition: all 0.3s;
                    min-width: 250px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                    The End
                </button>
            </div>
        \`;
    }

    /**
     * Get player scores HTML
     */
    getPlayerScoresHtml() {
        if (!this.playerScores || Object.keys(this.playerScores).length === 0) {
            return '<p>No scores available</p>';
        }
        
        const sortedScores = Object.entries(this.playerScores)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10); // Show top 10
        
        return \`
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                \${sortedScores.map(([playerId, score], index) => \`
                    <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 0.75rem;
                        background: rgba(255, 255, 255, \${index === 0 ? '0.3' : '0.15'});
                        border-radius: 6px;
                        \${index === 0 ? 'border: 2px solid #FFD700;' : ''}
                    ">
                        <span style="font-weight: bold;">
                            \${index === 0 ? '1st' : index === 1 ? '2nd' : index === 2 ? '3rd' : \`\${index + 1}.\`}
                            \${this.getPlayerName(playerId)}
                        </span>
                        <span style="font-weight: bold; font-size: 1.2rem;">
                            \${score} point\${score !== 1 ? 's' : ''}
                        </span>
                    </div>
                \`).join('')}
            </div>
        \`;
    }

    /**
     * Get final scores HTML with more details
     */
    getFinalScoresHtml() {
        if (!this.finalScores || this.finalScores.length === 0) {
            return this.getPlayerScoresHtml(); // Fallback to basic scores
        }
        
        return \`
            <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                \${this.finalScores.slice(0, 10).map((player, index) => \`
                    <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 1rem;
                        background: rgba(255, 255, 255, \${index === 0 ? '0.3' : '0.15'});
                        border-radius: 8px;
                        \${index === 0 ? 'border: 3px solid #FFD700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);' : ''}
                    ">
                        <span style="font-weight: bold; font-size: 1.2rem;">
                            \${index === 0 ? '' : index === 1 ? '' : index === 2 ? '' : \`\${index + 1}.\`}
                            \${player.name}
                        </span>
                        <div style="text-align: right;">
                            <div style="font-weight: bold; font-size: 1.4rem;">
                                \${player.score} point\${player.score !== 1 ? 's' : ''}
                            </div>
                            <div style="font-size: 0.9rem; opacity: 0.8;">
                                \${player.correctPredictions}/\${this.totalRounds} correct
                            </div>
                        </div>
                    </div>
                \`).join('')}
            </div>
        \`;
    }

    /**
     * Get round summary HTML
     */
    getRoundSummaryHtml() {
        if (!this.roundResults || this.roundResults.length === 0) {
            return '<p>No round data available</p>';
        }
        
        return \`
            <div style="display: flex; flex-direction: column; gap: 1rem;">
                \${this.roundResults.map((round, index) => \`
                    <div style="
                        padding: 1rem;
                        background: rgba(255, 255, 255, 0.15);
                        border-radius: 6px;
                        border-left: 4px solid #FFD700;
                    ">
                        <div style="font-weight: bold; margin-bottom: 0.5rem;">
                            Round \${index + 1}: \${round.question}
                        </div>
                        <div style="font-size: 0.9rem;">
                            Winner: <strong>\${round.winner}</strong> 
                            (\${round.winnerVotes}/\${round.totalVotes} votes)
                        </div>
                    </div>
                \`).join('')}
            </div>
        \`;
    }

    /**
     * Get player name from ID
     */
    getPlayerName(playerId) {
        if (this.players && this.players[playerId]) {
            return this.players[playerId].name || \`Player \${playerId.slice(-4)}\`;
        }
        return \`Player \${playerId.slice(-4)}\`;
    }

    /**
     * Attach event listeners after rendering
     */
    attachEventListeners() {
        // Vote buttons
        const voteBtns = this.gameAreaElement.querySelectorAll('.vote-btn');
        voteBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const vote = e.target.dataset.vote;
                if (vote && this.onPlayerAction) {
                    console.log(\`Player voting for: \${vote}\`);
                    this.myVote = vote; // Remember the vote
                    this.onPlayerAction({
                        type: 'submit_vote',
                        data: { vote: vote }
                    });
                }
            });
        });
        
        // Prediction buttons
        const predictionBtns = this.gameAreaElement.querySelectorAll('.prediction-btn');
        predictionBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const prediction = e.target.dataset.prediction;
                if (prediction && this.onPlayerAction) {
                    console.log(\` Player predicting: \${prediction}\`);
                    this.myPrediction = prediction; // Remember the prediction
                    this.onPlayerAction({
                        type: 'submit_prediction',
                        data: { prediction: prediction }
                    });
                }
            });
        });
        
        // Next Question button (host only, in results phase)
        const nextQuestionBtn = this.gameAreaElement.querySelector('#next-question-btn');
        if (nextQuestionBtn && this.onPlayerAction) {
            nextQuestionBtn.addEventListener('click', () => {
                console.log(' Next Question button clicked');
                this.onPlayerAction({
                    type: 'advance_round',
                    data: {}
                });
            });
        }
        
        // Continue to next round button (host only) - kept for backward compatibility
        const continueRoundBtn = this.gameAreaElement.querySelector('#continue-round-btn');
        if (continueRoundBtn && this.onPlayerAction) {
            continueRoundBtn.addEventListener('click', () => {
                console.log(' Continue to next round button clicked');
                this.onPlayerAction({
                    type: 'advance_round',
                    data: {}
                });
            });
        }
        
        // End Game button
        const endGameBtn = this.gameAreaElement.querySelector('#end-game-btn');
        if (endGameBtn && this.onPlayerAction) {
            endGameBtn.addEventListener('click', () => {
                console.log('End Game button clicked');
                this.onPlayerAction({
                    type: 'end_game',
                    data: {}
                });
            });
        }
        
        // New Game button
        const newGameBtn = this.gameAreaElement.querySelector('#new-game-btn');
        if (newGameBtn && this.onPlayerAction) {
            newGameBtn.addEventListener('click', () => {
                console.log('The End button clicked');
                // Show everyone wins screen
                this.showEveryoneWins();
            });
        }
    }

    /**
     * Handle player actions
     */
    handlePlayerAction(playerId, action) {
        // Actions are handled by the server
    }

    /**
     * Handle state updates from server
     */
    handleStateUpdate(gameSpecificState) {
        super.handleStateUpdate(gameSpecificState);
        
        // Update phase
        if (gameSpecificState.phase) {
            this.currentPhase = gameSpecificState.phase;
        }
        
        // Update question and options
        if (gameSpecificState.question) {
            this.question = gameSpecificState.question;
        }
        if (gameSpecificState.options) {
            this.options = gameSpecificState.options;
        }
        
        // Update results
        if (gameSpecificState.results) {
            this.results = gameSpecificState.results;
        }
        
        // Update multi-round state
        if (gameSpecificState.currentRound !== undefined) {
            this.currentRound = gameSpecificState.currentRound;
        }
        if (gameSpecificState.totalRounds !== undefined) {
            this.totalRounds = gameSpecificState.totalRounds;
        }
        if (gameSpecificState.roundResults) {
            this.roundResults = gameSpecificState.roundResults;
        }
        if (gameSpecificState.playerScores) {
            this.playerScores = gameSpecificState.playerScores;
        }
        if (gameSpecificState.finalScores) {
            this.finalScores = gameSpecificState.finalScores;
        }
        // Update host status
        if (gameSpecificState.hostId !== undefined) {
            this.isHost = (this.currentPlayerId === gameSpecificState.hostId);
        }
        if (gameSpecificState.isHost !== undefined) {
            this.isHost = gameSpecificState.isHost;
        }
        
        // Update vote counts for progress display
        if (gameSpecificState.votes) {
            this.votesCount = Object.keys(gameSpecificState.votes).length;
            // Check if we already voted
            if (gameSpecificState.votes[this.currentPlayerId]) {
                this.myVote = gameSpecificState.votes[this.currentPlayerId];
            }
        }
        
        // Update predictions
        if (gameSpecificState.predictions) {
            // Check if we already predicted
            if (gameSpecificState.predictions[this.currentPlayerId]) {
                this.myPrediction = gameSpecificState.predictions[this.currentPlayerId];
            }
        }
        
        if (gameSpecificState.players) {
            this.totalPlayers = Object.keys(gameSpecificState.players).length;
            this.players = gameSpecificState.players; // Store for name lookup
        }
        
        // Handle voting timer
        if (gameSpecificState.votingEndTime && this.currentPhase === 'VOTING') {
            this.timeRemaining = Math.max(0, Math.floor((gameSpecificState.votingEndTime - Date.now()) / 1000));
            this.startTimer();
        }
        
        // Handle prediction timer
        if (gameSpecificState.predictionEndTime && this.currentPhase === 'PREDICTING') {
            this.timeRemaining = Math.max(0, Math.floor((gameSpecificState.predictionEndTime - Date.now()) / 1000));
            this.startTimer();
        }
        
        this.render();
    }

    /**
     * Handle WebSocket messages
     */
    handleMessage(message) {
        console.log(' Handling message:', message.type, message);
        
        switch (message.type) {
            case 'game_started':
                console.log(' Game started message received:', message.data);
                if (message.data && message.data.phase) {
                    this.currentPhase = message.data.phase;
                    this.question = message.data.question || this.question;
                    this.options = message.data.options || this.options;
                    this.currentRound = message.data.currentRound || 1;
                    this.totalRounds = message.data.totalRounds || 3;
                    if (message.data.hostId) {
                        this.isHost = (this.currentPlayerId === message.data.hostId);
                    }
                }
                this.render();
                break;
                
            case 'phase_changed':
                this.currentPhase = message.phase;
                if (message.phase === 'PREDICTING') {
                    this.clearTimer();
                    if (message.timeLimit) {
                        this.timeRemaining = message.timeLimit;
                        this.startTimer();
                    }
                } else if (this.currentPhase !== 'VOTING' && this.currentPhase !== 'PREDICTING') {
                    this.clearTimer();
                }
                this.render();
                break;
                
            case 'voting_started':
                this.currentPhase = 'VOTING';
                this.question = message.question || 'Pizza or Burgers?';
                this.options = message.options || ['Pizza', 'Burgers'];
                this.timeRemaining = message.timeLimit || 10;
                this.myVote = null; // Reset vote for new round
                this.myPrediction = null; // Reset prediction for new round
                if (message.currentRound) this.currentRound = message.currentRound;
                if (message.totalRounds) this.totalRounds = message.totalRounds;
                this.startTimer();
                this.render();
                break;
                
            case 'predicting_started':
                console.log(' Predicting phase started:', message.data);
                this.currentPhase = 'PREDICTING';
                this.timeRemaining = message.data.timeLimit || 15;
                this.startTimer();
                this.render();
                break;
                
            case 'prediction_phase':
                console.log(' Prediction phase message:', message.data);
                if (message.data) {
                    this.currentPhase = message.data.phase || 'PREDICTING';
                    this.question = message.data.question || this.question;
                    this.options = message.data.options || this.options;
                    this.currentRound = message.data.currentRound || this.currentRound;
                    this.totalRounds = message.data.totalRounds || this.totalRounds;
                }
                this.render();
                break;
                
            case 'vote_confirmed':
                // Vote was successfully recorded
                this.render();
                break;
                
            case 'prediction_confirmed':
                // Prediction was successfully recorded
                this.render();
                break;
                
            case 'vote_count_update':
                this.votesCount = message.votesCount || 0;
                this.totalPlayers = message.totalPlayers || 0;
                this.render();
                break;
                
            case 'vote_progress':
                console.log(' Vote progress update:', message.data);
                this.votesCount = message.data.votesCount || 0;
                this.totalPlayers = message.data.totalPlayers || 0;
                this.lastVoterName = message.data.voterName;
                this.allVoted = message.data.allVoted || false;
                this.render();
                break;
                
            case 'round_results':
                console.log(' Round results received:', message.data);
                this.currentPhase = 'RESULTS';
                this.results = message.data.results;
                this.question = message.data.question;
                this.currentRound = message.data.currentRound;
                if (message.data.playerScores) {
                    this.playerScores = message.data.playerScores;
                }
                if (message.data.roundResults) {
                    this.roundResults = message.data.roundResults;
                }
                this.render();
                break;
                
            // Removed round_transition - we now auto-advance after results
                
            case 'host_assigned':
                console.log(' Host assigned:', message.data);
                this.isHost = (this.currentPlayerId === message.data.hostId);
                console.log(\` Is host: \${this.isHost}, currentPlayerId: \${this.currentPlayerId}, hostId: \${message.data.hostId}\`);
                this.render();
                break;
                
            case 'voting_results':
                console.log(' Voting results received:', message.data);
                this.currentPhase = 'RESULTS';
                this.results = message.data.results;
                this.question = message.data.question;
                this.render();
                break;
                
            case 'final_summary':
                console.log(' Final summary received:', message.data);
                this.currentPhase = 'ENDED';
                if (message.data.finalScores) {
                    this.finalScores = message.data.finalScores;
                }
                if (message.data.roundResults) {
                    this.roundResults = message.data.roundResults;
                }
                if (message.data.playerScores) {
                    this.playerScores = message.data.playerScores;
                }
                this.render();
                break;
                
            case 'advance_round':
                console.log(' Advancing to next round:', message.data);
                // Server will send new_round message for the next round
                break;
                
            case 'new_round':
                console.log(' New round started:', message.data);
                if (message.data) {
                    this.currentPhase = message.data.phase || 'VOTING';
                    this.question = message.data.question || this.question;
                    this.options = message.data.options || this.options;
                    this.currentRound = message.data.currentRound || this.currentRound;
                    this.totalRounds = message.data.totalRounds || this.totalRounds;
                    this.myVote = null; // Reset vote for new round
                    this.myPrediction = null; // Reset prediction for new round
                    if (message.data.hostId) {
                        this.isHost = (this.currentPlayerId === message.data.hostId);
                    }
                }
                this.render();
                break;
                
            case 'game_results':
                console.log(' Game results received:', message);
                this.currentPhase = 'RESULTS';
                this.results = message.results;
                this.question = message.question;
                this.render();
                break;
                
            case 'game_ended':
                console.log(' Game ended:', message.data);
                // Don't handle game_ended here - let GameShell show the unified end screen
                // GameShell will call showGameEndScreen() which has the OK button to return to lobby
                break;
                
            case 'final_results':
                console.log(' Final results message:', message.data);
                // Don't handle final_results here - let GameShell handle the game_ended message
                // to show the unified end screen with proper OK button functionality
                break;
                
            case 'error':
                console.error('Game error:', message.message);
                break;
                
            default:
                console.log(' Unhandled message type:', message.type);
                break;
        }
    }

    /**
     * Show everyone wins screen
     */
    showEveryoneWins() {
        // Hide the game area
        this.gameAreaElement.style.display = 'none';
        
        // Show the universal end game screen
        const endGameScreen = document.getElementById('end-game-screen');
        const resultMessage = document.getElementById('game-result-message');
        const finalScores = document.getElementById('final-scores');
        const okBtn = document.getElementById('ok-btn');
        
        if (endGameScreen && resultMessage && finalScores) {
            resultMessage.textContent = ' Everyone Wins! ';
            
            // Show player scores
            finalScores.innerHTML = this.getPlayerScoresHtml();
            
            // Show the screen
            endGameScreen.style.display = 'flex';
            
            // Handle OK button
            if (okBtn) {
                okBtn.onclick = () => {
                    if (this.onPlayerAction) {
                        this.onPlayerAction({
                            type: 'end_game',
                            data: {}
                        });
                    }
                };
            }
        }
    }

    /**
     * Clean up game resources
     */
    cleanup() {
        super.cleanup();
        this.clearTimer();
        this.currentPhase = 'WAITING';
        this.myVote = null;
        this.myPrediction = null;
        this.results = null;
        this.votesCount = 0;
        this.totalPlayers = 0;
        this.timeRemaining = 0;
        this.lastVoterName = null;
        this.allVoted = false;
        
        // Reset multi-round state
        this.currentRound = 1;
        this.totalRounds = 3;
        this.roundResults = [];
        this.playerScores = {};
        this.finalScores = [];
        this.isHost = false;
        this.players = null;
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = EverybodyVotesGameModule;
} else {
    window.EverybodyVotesGameModule = EverybodyVotesGameModule;
}`,
  '/static/js/games/PriceIsWeirdGameModule.js': `/**
 * PriceGameModule - Implements "The Price is Weird" 
 * A Price is Right clone using Etsy API for real product pricing
 */
class PriceGameModule extends GameModule {
    constructor() {
        super();
        // Game state will be initialized when implemented
    }

    /**
     * Initialize the game
     */
    init(gameAreaElement, players, initialState, onPlayerAction, onStateChange) {
        super.init(gameAreaElement, players, initialState, onPlayerAction, onStateChange);
        this.render();
    }

    /**
     * Render the game UI
     */
    render() {
        if (!this.gameAreaElement) return;
        
        this.gameAreaElement.innerHTML = \`
            <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 400px;
                background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
                border-radius: 12px;
                color: white;
                text-align: center;
                padding: 2rem;
            ">
                <h2 style="font-size: 2.5rem; margin-bottom: 1rem;">The Price is Weird</h2>
                <p style="font-size: 1.2rem; opacity: 0.9; margin-bottom: 2rem;">Price is Right Clone with Etsy Products</p>
                <div style="
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 8px;
                    padding: 1.5rem 2rem;
                    backdrop-filter: blur(10px);
                ">
                    <p style="font-size: 1.1rem; margin: 0;"> Coming Soon! </p>
                    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.8;">
                        Guess the price of real Etsy products without going over!
                    </p>
                </div>
            </div>
        \`;
    }

    /**
     * Handle player actions
     */
    handlePlayerAction(playerId, action) {
        // Will be implemented when game is ready
    }

    /**
     * Handle state updates from server
     */
    handleStateUpdate(gameSpecificState) {
        // Will be implemented when game is ready
        super.handleStateUpdate(gameSpecificState);
    }

    /**
     * Clean up game resources
     */
    cleanup() {
        super.cleanup();
        // Additional cleanup when implemented
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PriceGameModule;
} else {
    window.PriceGameModule = PriceGameModule;
}`,
  '/static/js/games/ThatsAPaddlinGameModule.js': `/**
 * PaddlinGameModule - Implements "That's a Paddlin'" (N-way pong game)
 * A multiplayer pong variant where N players control paddles around a shared play area
 */
class PaddlinGameModule extends GameModule {
    constructor() {
        super();
        // Game state will be initialized when implemented
    }

    /**
     * Initialize the game
     */
    init(gameAreaElement, players, initialState, onPlayerAction, onStateChange) {
        super.init(gameAreaElement, players, initialState, onPlayerAction, onStateChange);
        this.render();
    }

    /**
     * Render the game UI
     */
    render() {
        if (!this.gameAreaElement) return;
        
        this.gameAreaElement.innerHTML = \`
            <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 400px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 12px;
                color: white;
                text-align: center;
                padding: 2rem;
            ">
                <h2 style="font-size: 2.5rem; margin-bottom: 1rem;"> That's a Paddlin' </h2>
                <p style="font-size: 1.2rem; opacity: 0.9; margin-bottom: 2rem;">N-way Pong Game</p>
                <div style="
                    background: rgba(255, 255, 255, 0.2);
                    border-radius: 8px;
                    padding: 1.5rem 2rem;
                    backdrop-filter: blur(10px);
                ">
                    <p style="font-size: 1.1rem; margin: 0;"> Coming Soon! </p>
                    <p style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.8;">
                        Multiple players control paddles around a shared arena
                    </p>
                </div>
            </div>
        \`;
    }

    /**
     * Handle player actions
     */
    handlePlayerAction(playerId, action) {
        // Will be implemented when game is ready
    }

    /**
     * Handle state updates from server
     */
    handleStateUpdate(gameSpecificState) {
        // Will be implemented when game is ready
        super.handleStateUpdate(gameSpecificState);
    }

    /**
     * Clean up game resources
     */
    cleanup() {
        super.cleanup();
        // Additional cleanup when implemented
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PaddlinGameModule;
} else {
    window.PaddlinGameModule = PaddlinGameModule;
}`,
  '/static/styles.css': `/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
}

#app {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
header {
    background: rgba(255, 255, 255, 0.95);
    padding: 1rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    backdrop-filter: blur(10px);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

header h1 {
    color: #2c3e50;
    font-size: 1.8rem;
    font-weight: 600;
}

/* Special styling for company name only */
header h1.company-name {
    font-family: 'Cinzel Decorative', serif;
    font-weight: 700;
    font-size: 2rem;
    color: #8b4513;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    letter-spacing: 1px;
    background: linear-gradient(135deg, #8b4513 0%, #cd853f 50%, #8b4513 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

#connection-status {
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-size: 0.9rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.status-connected {
    background: #27ae60;
    color: white;
}

.status-disconnected {
    background: #e74c3c;
    color: white;
}

/* Main content */
main {
    flex: 1;
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
}

/* Views */
.view {
    display: none;
}

.view.active {
    display: block;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Game Portal */
#game-portal h2 {
    color: white;
    text-align: center;
    margin-bottom: 2rem;
    font-size: 2rem;
}

.games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
    margin-bottom: 3rem;
}

.game-card {
    position: relative;
    background: white;
    border: none;
    border-radius: 12px;
    padding: 2rem;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.game-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
}

.game-card.highlighted {
    border: 3px solid #3498db;
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
}

.game-card h3 {
    color: #2c3e50;
    font-size: 1.3rem;
    margin-bottom: 0.5rem;
}

.game-card p {
    color: #7f8c8d;
    font-size: 0.9rem;
}

/* Coming Soon Game Cards */
.game-card.coming-soon {
    background: 
        repeating-linear-gradient(
            45deg,
            #f1f3f4,
            #f1f3f4 4px,
            #e8eaed 4px,
            #e8eaed 8px
        );
    color: #9aa0a6;
    cursor: not-allowed;
    position: relative;
    opacity: 0.6;
    filter: grayscale(0.3);
}

.game-card.coming-soon:hover {
    transform: none;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
}

.game-card.coming-soon h3 {
    color: #80868b;
}

.game-card.coming-soon p {
    color: #9aa0a6;
}

.coming-soon-badge {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: linear-gradient(135deg, #ff9500, #ff6b00);
    color: white;
    padding: 0.25rem 0.75rem;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 8px rgba(255, 149, 0, 0.3);
}

.join-room-section {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 16px;
    padding: 2.5rem;
    backdrop-filter: blur(10px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.join-room-section h3 {
    color: #2c3e50;
    margin-bottom: 2rem;
    font-size: 1.5rem;
    font-weight: 600;
    text-align: center;
}

.join-layout {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 2rem;
    align-items: start;
}

.manual-join-section {
    display: flex;
    justify-content: stretch;
}

.manual-join-section .join-method {
    width: 100%;
}

.join-method {
    flex: 1;
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 1.5rem;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.join-method:hover {
    border-color: #3498db;
    box-shadow: 0 4px 20px rgba(52, 152, 219, 0.15);
    transform: translateY(-2px);
}

.join-method.active {
    border-color: #3498db;
    background: rgba(52, 152, 219, 0.05);
}

.join-method h4 {
    color: #2c3e50;
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}


.manual-join {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

#room-code-input {
    padding: 1rem 1.25rem;
    border: 2px solid #e0e0e0;
    border-radius: 10px;
    font-size: 1.1rem;
    text-transform: uppercase;
    letter-spacing: 3px;
    font-weight: 700;
    text-align: center;
    background: white;
    transition: all 0.2s ease;
}

#room-code-input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.15);
    transform: scale(1.02);
}

#join-room-btn {
    padding: 1rem 2rem;
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
}

#join-room-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

#join-room-btn:active {
    transform: translateY(-1px);
}

.active-rooms {
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 1.5rem;
    transition: all 0.3s ease;
    height: fit-content;
}

.active-rooms:hover {
    border-color: #3498db;
    box-shadow: 0 4px 20px rgba(52, 152, 219, 0.15);
}

.active-rooms-header {
    position: relative;
    margin-bottom: 1.2rem;
}

.active-rooms h4 {
    color: #2c3e50;
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
    text-align: center;
    position: relative;
}

.refresh-btn {
    position: absolute;
    top: 0;
    right: 8px;
    background: none;
    border: none;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s ease;
    color: #8e9297;
    opacity: 0.4;
    border-radius: 3px;
}

.refresh-btn:hover {
    color: #2c3e50;
    opacity: 0.8;
    background: rgba(52, 152, 219, 0.08);
}

.refresh-btn:active {
    transform: scale(0.9);
}

.refresh-btn.refreshing {
    animation: spin 1s linear infinite;
    pointer-events: none;
    opacity: 0.7;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.active-rooms h4::before {
    content: '';
    position: absolute;
    bottom: -0.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 3px;
    background: linear-gradient(135deg, #3498db, #2980b9);
    border-radius: 2px;
}

.rooms-list {
    display: grid;
    gap: 1rem;
    max-height: 400px;
    overflow-y: auto;
    padding-right: 0.5rem;
}

.rooms-list::-webkit-scrollbar {
    width: 6px;
}

.rooms-list::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}

.rooms-list::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
}

.rooms-list::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

.room-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: white;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 1.25rem;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    position: relative;
    overflow: hidden;
}

.room-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(135deg, #27ae60, #219a52);
    transform: scaleX(0);
    transition: transform 0.3s ease;
}

.room-item:hover {
    border-color: #3498db;
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.15);
    transform: translateY(-2px);
}

.room-item:hover::before {
    transform: scaleX(1);
}

.room-info {
    flex: 1;
}

.room-title {
    font-weight: 700;
    color: #2c3e50;
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
}


.room-code {
    font-family: 'Courier New', monospace;
    font-size: 1rem;
    color: #6c757d;
    margin-bottom: 0.5rem;
    background: rgba(52, 152, 219, 0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    display: inline-block;
    font-weight: 600;
    letter-spacing: 1px;
}

/* CRITICAL: Player emoji display in active rooms - DO NOT REMOVE */
.room-emojis {
    font-size: 1.4rem;
    line-height: 1.5;
    margin: 0.5rem 0;
    letter-spacing: 0.3em;
    min-height: 2rem;
    color: #333;
    font-weight: 500;
}

.room-time {
    font-size: 0.8rem;
    color: #6c757d;
    opacity: 0.8;
}

.join-room-btn {
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, #27ae60, #219a52);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 3px 12px rgba(39, 174, 96, 0.3);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.join-room-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 16px rgba(39, 174, 96, 0.4);
}

.join-room-btn:active {
    transform: translateY(0);
}

.loading-rooms, .no-rooms {
    text-align: center;
    color: #6c757d;
    font-style: italic;
    padding: 2rem;
    background: rgba(108, 117, 125, 0.05);
    border-radius: 12px;
    border: 2px dashed #dee2e6;
}


@media (max-width: 768px) {
    .join-room-section {
        padding: 2rem;
    }
    
    .join-layout {
        grid-template-columns: 1fr;
        gap: 1.5rem;
    }
    
    .manual-join-section .join-method {
        max-width: none;
    }
    
    .join-method {
        padding: 1.25rem;
    }
    
    .join-method h4 {
        font-size: 1rem;
    }
    
    .active-rooms h4 {
        font-size: 1.1rem;
    }
    
    .rooms-list {
        max-height: 300px;
    }
    
    .room-item {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
        text-align: center;
    }
    
    .join-room-btn {
        width: 100%;
    }
}

/* Game Room */
.room-header {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
}

.header-left {
    flex: 1;
    min-width: 0;
}

.header-right {
    flex: 1;
    min-width: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 1.5rem;
    backdrop-filter: blur(10px);
}

.rules-box {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 1.5rem;
    backdrop-filter: blur(10px);
    height: 100%;
}

.rules-box h3 {
    color: #2c3e50;
    margin: 0 0 1rem 0;
    font-size: 1.2rem;
    border-bottom: 2px solid #e74c3c;
    padding-bottom: 0.5rem;
}

#game-rules-content {
    color: #34495e;
    line-height: 1.6;
}

#game-rules-content ul {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
}

#game-rules-content li {
    margin: 0.3rem 0;
}

.room-info h2 {
    color: #2c3e50;
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.room-code {
    color: #7f8c8d;
    font-family: 'Courier New', monospace;
    font-size: 1rem;
    font-weight: 600;
}

#leave-room-btn {
    padding: 0.75rem 1.5rem;
    background: #e74c3c;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

#leave-room-btn:hover {
    background: #c0392b;
    transform: translateY(-2px);
}

/* game-status div removed from HTML */

/* Player Info Container */
.player-info-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
}

.player-info-container h3 {
    color: #2c3e50;
    margin-bottom: 1rem;
    font-size: 1.2rem;
}

.players-list {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
}

.players-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.players-list h3 {
    color: #2c3e50;
    font-size: 1.2rem;
    margin: 0;
}

/* Game Area - Where specific game modules render */
.game-area {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(52, 152, 219, 0.3);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
}

#start-game-btn-header {
    padding: 0.5rem 1rem;
    background: #27ae60;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}

#start-game-btn-header:hover {
    background: #219a52;
    transform: translateY(-2px);
}

.player {
    display: flex;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid #ecf0f1;
}

.player:last-child {
    border-bottom: none;
}

.player-name {
    color: #2c3e50;
    font-weight: 500;
    flex: 1;
}

.player-symbol {
    color: #7f8c8d;
    font-weight: 600;
    margin-left: 0.5rem;
}

.player-status {
    color: #27ae60;
    font-size: 1.2rem;
    margin-left: 0.5rem;
}

/* Game Boards */
#game-board-container {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 2rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.empty-board {
    color: #7f8c8d;
    font-size: 1.1rem;
    text-align: center;
}

/* Tic Tac Toe Board */
.tic-tac-toe-board {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    max-width: 300px;
    margin: 0 auto;
}

.tic-tac-toe-cell {
    width: 80px;
    height: 80px;
    background: #ecf0f1;
    border: 2px solid #bdc3c7;
    border-radius: 8px;
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
    cursor: pointer;
    transition: all 0.2s ease;
}

.tic-tac-toe-cell:hover:not(:disabled) {
    background: #d5dbdb;
    transform: scale(1.05);
}

.tic-tac-toe-cell:disabled {
    cursor: not-allowed;
    opacity: 0.7;
}

/* Connect Four Board */
.connect-four-board {
    text-align: center;
}

.connect-four-columns {
    display: flex;
    justify-content: center;
    margin-bottom: 1rem;
}

.connect-four-column-btn {
    width: 40px;
    height: 40px;
    margin: 0 2px;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.connect-four-column-btn:hover {
    background: #2980b9;
    transform: translateY(-2px);
}

.connect-four-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    grid-template-rows: repeat(6, 1fr);
    gap: 5px;
    max-width: 350px;
    margin: 0 auto;
}

.connect-four-cell {
    width: 45px;
    height: 45px;
    background: #ecf0f1;
    border: 2px solid #bdc3c7;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: bold;
}

.connect-four-cell.filled {
    background: #e74c3c;
    color: white;
}

/* Rock Paper Scissors Board */
.rock-paper-scissors-board {
    text-align: center;
}

.rock-paper-scissors-board h3 {
    color: #2c3e50;
    margin-bottom: 1.5rem;
    font-size: 1.3rem;
}

.rps-choices {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 2rem;
}

.rps-choice {
    padding: 1rem 2rem;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    min-width: 120px;
}

.rps-choice:hover {
    background: #2980b9;
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.rps-results {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1rem;
    max-height: 200px;
    overflow-y: auto;
}

.rps-move {
    padding: 0.5rem 0;
    border-bottom: 1px solid #e9ecef;
    color: #495057;
}

.rps-move:last-child {
    border-bottom: none;
}

/* Generic Board */
.generic-board {
    text-align: center;
}

.generic-board p {
    color: #2c3e50;
    font-size: 1.1rem;
    margin-bottom: 1rem;
}

.generic-board pre {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1rem;
    text-align: left;
    font-size: 0.9rem;
    color: #495057;
    overflow-x: auto;
}

/* Game Controls */
.game-controls {
    text-align: center;
}

#restart-game-btn {
    padding: 0.75rem 2rem;
    background: #27ae60;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}

#restart-game-btn:hover {
    background: #219a52;
    transform: translateY(-2px);
}

/* Loading Overlay */
.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
}

.spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.overlay p {
    color: white;
    font-size: 1.1rem;
    font-weight: 500;
}

/* Error Messages */
.error-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1001;
}

.error-message {
    background: #e74c3c;
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    margin-bottom: 0.5rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    animation: slideIn 0.3s ease-out;
    max-width: 400px;
}

.error-message.fade-out {
    animation: fadeOut 0.3s ease-out forwards;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes fadeOut {
    from {
        opacity: 1;
        transform: scale(1);
    }
    to {
        opacity: 0;
        transform: scale(0.95);
    }
}

/* Responsive Design */
@media (max-width: 768px) {
    header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
    }

    main {
        padding: 1rem;
    }

    .games-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }

    .room-header {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
    }

    #room-code-input {
        margin-right: 0;
        margin-bottom: 1rem;
        width: 100%;
        max-width: 200px;
    }

    .rps-choices {
        flex-direction: column;
        align-items: center;
    }

    .connect-four-grid {
        max-width: 280px;
    }

    .connect-four-cell {
        width: 35px;
        height: 35px;
    }

    .tic-tac-toe-cell {
        width: 60px;
        height: 60px;
        font-size: 1.5rem;
    }

    .error-message {
        margin: 0 10px;
        max-width: calc(100vw - 40px);
    }
}

/* Button States */
button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

button:active {
    transform: scale(0.98);
}

/* Focus styles for accessibility */
button:focus,
input:focus {
    outline: 2px solid #3498db;
    outline-offset: 2px;
}

/* Drawing Game Styles */
.drawing-controls {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
}

.drawing-tools {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
}

.drawing-tools label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #2c3e50;
    font-weight: 500;
}

.drawing-tools input[type="color"] {
    width: 40px;
    height: 30px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.drawing-tools input[type="range"] {
    width: 100px;
}

#clear-canvas-btn {
    padding: 0.5rem 1rem;
    background: #e74c3c;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

#clear-canvas-btn:hover {
    background: #c0392b;
}

.word-display {
    text-align: center;
    font-size: 1.5rem;
    font-weight: 600;
    color: #2c3e50;
    margin: 1rem 0;
    padding: 1rem;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px dashed #bdc3c7;
}

.guess-input {
    display: flex;
    align-items: center;
    gap: 1rem;
    justify-content: center;
    margin: 1rem 0;
}

#guess-input {
    padding: 0.75rem 1rem;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 1rem;
    flex: 1;
    max-width: 300px;
}

#guess-input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

#submit-guess-btn {
    padding: 0.75rem 1.5rem;
    background: #27ae60;
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

#submit-guess-btn:hover {
    background: #219a52;
}

.game-timer {
    text-align: center;
    font-size: 1.2rem;
    font-weight: 600;
    color: #e74c3c;
    margin-top: 1rem;
}

#start-game-btn {
    padding: 0.75rem 2rem;
    background: #27ae60;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-right: 1rem;
}

#start-game-btn:hover {
    background: #219a52;
    transform: translateY(-2px);
}

.drawing-canvas {
    border: 2px solid #bdc3c7;
    border-radius: 8px;
    cursor: crosshair;
    display: block;
    margin: 0 auto;
    max-width: 100%;
    background: white;
}

.drawing-canvas.disabled {
    cursor: not-allowed;
    opacity: 0.7;
}

@media (max-width: 768px) {
    .drawing-tools {
        justify-content: center;
    }
    
    .guess-input {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    #guess-input {
        max-width: 100%;
    }
    
    .drawing-canvas {
        max-width: 90vw;
        max-height: 60vh;
    }
}

/* Floating Emoji Animations */
@keyframes move-x {
    0% { transform: translateX(0vw); }
    100% { transform: translateX(90vw); }
}

@keyframes move-x-chaos1 {
    0% { transform: translateX(0vw); }
    25% { transform: translateX(70vw); }
    50% { transform: translateX(20vw); }
    75% { transform: translateX(80vw); }
    100% { transform: translateX(10vw); }
}

@keyframes move-x-chaos2 {
    0% { transform: translateX(0vw); }
    20% { transform: translateX(30vw); }
    40% { transform: translateX(85vw); }
    60% { transform: translateX(15vw); }
    80% { transform: translateX(60vw); }
    100% { transform: translateX(5vw); }
}

@keyframes move-y {
    0% { transform: translateY(0vh); }
    100% { transform: translateY(80vh); }
}

@keyframes move-y-chaos1 {
    0% { transform: translateY(0vh); }
    25% { transform: translateY(60vh); }
    50% { transform: translateY(20vh); }
    75% { transform: translateY(70vh); }
    100% { transform: translateY(10vh); }
}

@keyframes move-y-chaos2 {
    0% { transform: translateY(0vh); }
    20% { transform: translateY(40vh); }
    40% { transform: translateY(75vh); }
    60% { transform: translateY(15vh); }
    80% { transform: translateY(55vh); }
    100% { transform: translateY(5vh); }
}

@keyframes float {
    0%, 100% { transform: translateY(0px) rotate(0deg); }
    25% { transform: translateY(-10px) rotate(2deg); }
    50% { transform: translateY(5px) rotate(-2deg); }
    75% { transform: translateY(-5px) rotate(1deg); }
}

/* Floating emoji base styles */
.floating-emoji {
    position: fixed !important;
    z-index: 10000 !important;
    pointer-events: none !important;
    user-select: none !important;
    font-size: 4rem !important;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3) !important;
}

.floating-emoji-x {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 10000 !important;
    pointer-events: none !important;
    user-select: none !important;
}

.floating-emoji-y {
    font-size: 4rem !important;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3) !important;
}

/* Checkbox Game Styles */
.checkbox-game-ui {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 2rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.game-info-container h3 {
    color: #2c3e50;
    font-size: 1.5rem;
    font-weight: 600;
    text-align: center;
    margin-bottom: 1.5rem;
}

.connection-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    padding: 1rem 1.5rem;
    margin-bottom: 2rem;
    transition: all 0.3s ease;
}

.connection-info:hover {
    border-color: #3498db;
    box-shadow: 0 4px 20px rgba(52, 152, 219, 0.15);
}

.connection-status {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-weight: 600;
    font-size: 1rem;
}

.status-indicator {
    font-size: 1.2rem;
    font-weight: bold;
    text-shadow: 0 0 3px currentColor;
    transition: all 0.3s ease;
}

.status-indicator.connected {
    color: #27ae60;
    animation: pulse-connected 2s ease-in-out infinite;
}

.status-indicator.disconnected {
    color: #e74c3c;
    animation: pulse-disconnected 1.5s ease-in-out infinite;
}

@keyframes pulse-connected {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.1); }
}

@keyframes pulse-disconnected {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.player-count-display {
    color: #495057;
    font-weight: 600;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.player-count-display::before {
    content: "";
    font-size: 1.2rem;
}

.checkbox-grid-container {
    display: flex;
    justify-content: center;
    margin: 2rem 0;
}

.checkbox-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 3px solid #dee2e6;
    border-radius: 16px;
    box-shadow: 
        inset 0 2px 8px rgba(0, 0, 0, 0.1),
        0 4px 20px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
}

.checkbox-grid:hover {
    box-shadow: 
        inset 0 2px 8px rgba(0, 0, 0, 0.15),
        0 6px 25px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.checkbox-item {
    width: 80px;
    height: 80px;
    background: white;
    border: 3px solid #bdc3c7;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    user-select: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.checkbox-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #3498db, #2980b9);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 1;
}

.checkbox-item:hover:not(.checked) {
    border-color: #3498db;
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
}

.checkbox-item:hover:not(.checked)::before {
    opacity: 0.1;
}

.checkbox-item.checked {
    background: linear-gradient(135deg, #27ae60 0%, #219a52 100%);
    border-color: #219a52;
    transform: scale(1.02);
    box-shadow: 
        0 4px 20px rgba(39, 174, 96, 0.4),
        inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

.checkbox-item.checked .checkbox-icon {
    color: white;
    font-size: 2.5rem;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    animation: checkmark-bounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    z-index: 2;
    position: relative;
}

@keyframes checkmark-bounce {
    0% { 
        transform: scale(0) rotate(180deg);
        opacity: 0;
    }
    50% { 
        transform: scale(1.3) rotate(0deg);
        opacity: 0.8;
    }
    100% { 
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
}

.checkbox-item:active {
    transform: scale(0.95);
}

.game-instructions {
    text-align: center;
    background: rgba(52, 152, 219, 0.1);
    border: 2px solid rgba(52, 152, 219, 0.2);
    border-radius: 10px;
    padding: 1.25rem;
    margin-top: 2rem;
}

.game-instructions p {
    color: #2c3e50;
    font-size: 1.1rem;
    font-weight: 500;
    margin: 0;
    line-height: 1.5;
}

/* Mobile Responsive Design for Checkbox Game */
@media (max-width: 768px) {
    .checkbox-game-ui {
        padding: 1.5rem;
        margin: 0 -0.5rem 1.5rem -0.5rem;
    }
    
    .game-info-container h3 {
        font-size: 1.3rem;
    }
    
    .connection-info {
        flex-direction: column;
        gap: 1rem;
        text-align: center;
    }
    
    .checkbox-grid {
        gap: 10px;
        padding: 15px;
    }
    
    .checkbox-item {
        width: 60px;
        height: 60px;
    }
    
    .checkbox-item.checked .checkbox-icon {
        font-size: 2rem;
    }
    
    .game-instructions {
        padding: 1rem;
    }
    
    .game-instructions p {
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .checkbox-grid {
        gap: 8px;
        padding: 12px;
    }
    
    .checkbox-item {
        width: 50px;
        height: 50px;
        border-radius: 8px;
    }
    
    .checkbox-item.checked .checkbox-icon {
        font-size: 1.5rem;
    }
}

/* Emoji Picker Override - Force on top with absolute positioning */
#emoji-picker {
    position: absolute !important;
    z-index: 999999 !important;
    background: white !important;
    border: 2px solid #ccc !important;
    border-radius: 8px !important;
    padding: 10px !important;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3) !important;
    width: 300px !important;
    max-height: 400px !important;
    overflow-y: auto !important;
    top: 40px !important;
    left: 0 !important;
}

/* Smooth transitions */
* {
    transition: opacity 0.2s ease, transform 0.2s ease;
}

/* Checkbox Game Styles */
.checkbox-game-board {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    padding: 2rem;
    margin-bottom: 1.5rem;
    backdrop-filter: blur(10px);
    text-align: center;
}

.checkbox-game-board .game-info h3 {
    color: #2c3e50;
    font-size: 1.3rem;
    margin-bottom: 0.5rem;
}

.checkbox-game-board .game-info p {
    color: #7f8c8d;
    font-size: 0.9rem;
    margin-bottom: 1.5rem;
}

.game-layout {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 3rem;
    margin-top: 2rem;
}

.scoreboard {
    background: #f8f9fa;
    border: 2px solid #dee2e6;
    border-radius: 12px;
    padding: 1.5rem;
    min-width: 200px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.scoreboard h4 {
    color: #2c3e50;
    font-size: 1.2rem;
    font-weight: 600;
    text-align: center;
    margin-bottom: 1rem;
    border-bottom: 2px solid #3498db;
    padding-bottom: 0.5rem;
}

.score-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: white;
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 0.75rem 1rem;
    transition: all 0.2s ease;
}

.score-item:hover {
    border-color: #3498db;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.15);
}

.score-player {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 500;
    color: #2c3e50;
}

.score-player-emoji {
    font-size: 1.2rem;
}

.score-points {
    font-weight: bold;
    color: #27ae60;
    font-size: 1.1rem;
    background: rgba(39, 174, 96, 0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    min-width: 30px;
    text-align: center;
}

/* End Game Screen */
.end-game-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10001;
    backdrop-filter: blur(10px);
}

.end-game-content {
    background: white;
    border-radius: 16px;
    padding: 3rem;
    text-align: center;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    animation: gameEndFadeIn 0.5s ease-out;
    position: relative;
    margin: auto;
}

@keyframes gameEndFadeIn {
    from {
        opacity: 0;
        transform: scale(0.8) translateY(50px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

#game-result-message {
    color: #2c3e50;
    font-size: 2.5rem;
    font-weight: bold;
    margin: 0 auto 2rem auto;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    text-align: center;
    display: block;
    width: 100%;
}

.final-scores {
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 2rem;
}

.final-scores h4 {
    color: #2c3e50;
    font-size: 1.3rem;
    margin-bottom: 1rem;
}

.final-score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 0;
    border-bottom: 1px solid #dee2e6;
    font-size: 1.1rem;
}

.final-score-item:last-child {
    border-bottom: none;
}

.final-score-player {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-weight: 500;
    color: #2c3e50;
}

.final-score-emoji {
    font-size: 1.3rem;
}

.final-score-points {
    font-weight: bold;
    color: #27ae60;
    font-size: 1.2rem;
}

.ok-btn {
    padding: 1rem 3rem;
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.ok-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
    background: linear-gradient(135deg, #2980b9, #1f5f8b);
}

.ok-btn:active {
    transform: translateY(-1px);
}

/* Duplicate checkbox styles removed - see lines 1428-1510 for checkbox styling */

/* Name control responsive styles */
.responsive-name-control {
    display: flex;
    gap: 12px;
    align-items: center;
}

.name-input-group {
    display: flex;
    gap: 8px;
    flex: 1;
    align-items: center;
}

.name-input {
    padding: 10px 12px;
    border: 2px solid #ddd;
    border-radius: 6px;
    flex: 1;
    font-size: 14px;
    box-sizing: border-box;
}

.update-btn {
    padding: 10px 20px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
    white-space: nowrap;
}

/* Responsive breakpoint aligned with header wrapping (when "Incorporated" moves to second line) */
@media (max-width: 820px) {
    .responsive-name-control {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
    }
    
    .name-label {
        min-width: unset !important;
    }
    
    .name-input-group {
        flex-direction: column;
        gap: 8px;
    }
    
    .name-input {
        width: 100%;
    }
    
    .update-btn {
        width: 100%;
        padding: 12px 20px;
        font-size: 16px; /* Better touch target */
    }
}

/* Additional mobile-specific adjustments */
@media (max-width: 600px) {
    /* Adjust player controls padding on mobile */
    #player-controls {
        padding-left: 20px !important;
        min-width: unset !important;
    }
    
    /* Stack the Players and Who Are You sections vertically */
    .waiting-room-content > div {
        flex-direction: column !important;
        gap: 30px;
    }
    
    .waiting-room-content > div > .players-list {
        border-right: none !important;
        padding-right: 0 !important;
        border-bottom: 2px solid #e0e0e0;
        padding-bottom: 30px;
    }
    
    .waiting-room-content > div > #player-controls {
        border-left: none !important;
    }
}


/* Mobile responsive styles for new layout */
@media (max-width: 768px) {
    .checkbox-grid {
        max-width: 240px;
        gap: 8px;
    }
    
    .checkbox-item {
        width: 50px;
        height: 50px;
    }
    
    .checkbox-item.checked::after {
        font-size: 20px;
    }
    
    .game-layout {
        flex-direction: column;
        align-items: center;
        gap: 2rem;
    }
    
    .scoreboard {
        width: 100%;
        max-width: 300px;
        order: 2;
    }
    
    .checkbox-grid {
        order: 1;
    }
    
    .end-game-content {
        padding: 2rem;
        margin: 1rem;
    }
    
    #game-result-message {
        font-size: 1.5rem;
    }
    
    .final-scores {
        padding: 1rem;
    }
    
    .ok-btn {
        padding: 0.75rem 2rem;
        font-size: 1rem;
    }
}

/* Version Info Footer */
.version-info {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0, 0, 0, 0.7);
    color: rgba(255, 255, 255, 0.8);
    padding: 0.5rem 1rem;
    backdrop-filter: blur(10px);
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    z-index: 100;
}

#version-display {
    font-family: 'Courier New', monospace;
    font-size: 0.75rem;
    text-align: center;
    letter-spacing: 0.5px;
}

/* Ensure main content doesn't overlap footer */
main {
    padding-bottom: 3rem;
}

/* Chat Area - Yahoo! Games-style chat interface */
.chat-area {
    background: #e8e8e8;
    border: 2px solid #999;
    border-radius: 0;
    padding: 0;
    margin-bottom: 1.5rem;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    height: 400px;
}

.chat-header {
    background: linear-gradient(180deg, #5a9fd4 0%, #3d7fb8 100%);
    color: white;
    padding: 0.4rem 0.75rem;
    border-bottom: 2px solid #2d5a8e;
    box-shadow: 0 2px 3px rgba(0, 0, 0, 0.2);
}

.chat-header h3 {
    font-size: 0.95rem;
    margin: 0;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    letter-spacing: 0.5px;
}

.chat-main-container {
    display: flex;
    flex: 1;
    background: white;
    overflow: hidden;
}

.chat-messages-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: white;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
    background: white;
    font-family: 'Verdana', 'Arial', sans-serif;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.chat-messages-wrapper {
    margin-top: auto;
}

.chat-message {
    padding: 0.2rem 0;
    margin-bottom: 0.2rem;
    word-wrap: break-word;
    font-size: 0.8rem;
    line-height: 1.3;
}

.chat-author {
    font-weight: bold;
    color: #0066cc;
    margin-right: 0.3rem;
    font-size: 0.8rem;
}

.chat-text {
    color: #000;
    font-size: 0.8rem;
}

.chat-input-area {
    display: flex;
    gap: 0.4rem;
    padding: 0.5rem;
    background: #f0f0f0;
    border-top: 1px solid #ccc;
}

.chat-users-panel {
    width: 180px;
    background: #f5f5f5;
    border-left: 2px solid #ccc;
    display: flex;
    flex-direction: column;
}

.chat-users-list {
    flex: 1;
    overflow-y: auto;
    padding: 0;
}

.chat-users-section {
    border-bottom: 1px solid #ddd;
}

.chat-users-section:last-child {
    border-bottom: none;
}

.chat-users-header {
    font-size: 0.7rem;
    font-weight: bold;
    color: #444;
    text-transform: uppercase;
    padding: 0.4rem 0.5rem;
    background: linear-gradient(180deg, #e0e0e0 0%, #d0d0d0 100%);
    border-bottom: 1px solid #bbb;
    border-top: 1px solid #fff;
    letter-spacing: 0.5px;
    font-family: 'Verdana', 'Arial', sans-serif;
}

.chat-user-item {
    display: flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-family: 'Verdana', 'Arial', sans-serif;
    transition: background-color 0.15s;
    cursor: default;
}

.chat-user-item:hover {
    background: #d4e4f4;
}

.chat-user-item.spectator {
    font-style: italic;
    opacity: 0.85;
}

.chat-user-emoji {
    margin-right: 0.35rem;
    font-size: 0.85rem;
}

.chat-user-name {
    flex: 1;
    color: #222;
    font-weight: 500;
}

.chat-user-badge {
    margin-left: 0.3rem;
    font-size: 0.75rem;
}

#chat-input {
    flex: 1;
    padding: 0.35rem 0.5rem;
    border: 1px solid #999;
    border-radius: 2px;
    font-size: 0.8rem;
    font-family: 'Verdana', 'Arial', sans-serif;
    background: white;
}

#chat-input:focus {
    outline: none;
    border-color: #4a90e2;
    box-shadow: inset 0 0 3px rgba(74, 144, 226, 0.3);
}

#chat-send-btn {
    padding: 0.35rem 0.9rem;
    background: linear-gradient(180deg, #6db3f2 0%, #4a90e2 50%, #3d7fb8 100%);
    color: white;
    border: 1px solid #2d5a8e;
    border-radius: 2px;
    font-weight: bold;
    font-size: 0.75rem;
    font-family: 'Verdana', 'Arial', sans-serif;
    cursor: pointer;
    transition: all 0.15s;
    text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

#chat-send-btn:hover:not(:disabled) {
    background: linear-gradient(180deg, #5da2e2 0%, #3a80d2 50%, #2d6fa8 100%);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

#chat-send-btn:active:not(:disabled) {
    transform: translateY(1px);
    box-shadow: 0 0 1px rgba(0, 0, 0, 0.2);
}

#chat-send-btn:disabled {
    background: #c0c0c0;
    border-color: #999;
    color: #666;
    cursor: not-allowed;
    opacity: 0.7;
    text-shadow: none;
}

/* County Game Styles */
.county-game-waiting,
.county-game-submission,
.county-game-announcement {
    text-align: center;
    padding: 2rem;
    max-width: 600px;
    margin: 0 auto;
}

.county-game-submission h2 {
    color: #333;
    margin-bottom: 1rem;
}

.county-game-submission .timer-display {
    font-size: 1.2rem;
    color: #666;
    margin-bottom: 2rem;
    font-weight: 600;
}

.county-game-submission .submission-form {
    background: white;
    padding: 2rem;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.county-game-submission #county-input {
    width: 100%;
    max-width: 400px;
    padding: 0.75rem;
    font-size: 1.1rem;
    border: 2px solid #ddd;
    border-radius: 6px;
    margin: 1rem 0;
    text-align: center;
}

.county-game-submission #county-input:focus {
    outline: none;
    border-color: #007bff;
}

.county-game-submission .submit-btn {
    background: #28a745;
    color: white;
    border: none;
    padding: 0.75rem 2rem;
    font-size: 1.1rem;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
}

.county-game-submission .submit-btn:hover {
    background: #218838;
}

.county-game-submission .submission-complete {
    background: #f8f9fa;
    padding: 2rem;
    border-radius: 12px;
    border: 2px solid #28a745;
}

.county-game-submission .submitted-county {
    font-size: 1.2rem;
    color: #333;
    margin: 1rem 0;
}

.county-game-submission .submission-status {
    margin-top: 1.5rem;
    font-size: 1rem;
    color: #666;
    padding: 0.5rem;
    background: white;
    border-radius: 6px;
}

/* County Game Announcement Phase */
.county-game-announcement h2 {
    color: #333;
    margin-bottom: 2rem;
}

.announcement-display {
    background: #ffffff;
    padding: 2.5rem 2rem;
    border-radius: 16px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.08);
    margin: 2rem auto;
    animation: slideIn 0.5s ease-out;
    max-width: 500px;
    border: 1px solid #e8f0fe;
    text-align: center;
    position: relative;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.announcement-display .player-number {
    font-size: 0.9rem;
    color: #8b92a8;
    margin-bottom: 1.5rem;
    font-weight: 600;
    letter-spacing: 3px;
    text-transform: uppercase;
}

.announcement-display .player-info {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
}

.announcement-display .player-emoji {
    font-size: 2.5rem;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
}

.announcement-display .player-name {
    font-size: 1.5rem;
    color: #2c3e50;
    font-weight: 600;
}

.announcement-display .county-name {
    font-size: 2.2rem;
    color: #5e72e4;
    font-weight: 700;
    margin-top: 1rem;
    font-style: normal;
    line-height: 1.3;
    word-wrap: break-word;
    padding: 0 1rem;
}

.announcement-waiting {
    padding: 3rem;
    background: #f8f9fa;
    border-radius: 12px;
    color: #666;
}

.host-controls {
    margin-top: 2rem;
}

.host-controls .control-btn {
    background: #5e72e4;
    color: white;
    border: none;
    padding: 0.9rem 2.5rem;
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 12px rgba(94, 114, 228, 0.25);
    letter-spacing: 0.5px;
    text-transform: uppercase;
}

.host-controls .control-btn:hover {
    background: #4c63d2;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(94, 114, 228, 0.35);
}

.host-controls .control-btn:active {
    transform: translateY(0);
}

.host-controls p {
    color: #666;
    font-size: 1.1rem;
    margin-bottom: 1rem;
}`,
  '/static/version.json': `{
  "version": "1.1.2",
  "baseVersion": "1.1.2",
  "branch": "county-game",
  "commit": "a177739",
  "timestamp": "2025-08-18T03:11:57.758Z",
  "deployedAt": "Aug 17, 2025, 09:11 PM MDT"
}`
};

export const assetPaths = Object.keys(staticAssets);
