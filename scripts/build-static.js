#!/usr/bin/env node

/**
 * Build script to embed static assets into the Cloudflare Worker
 * Reads files from src/static/ and creates src/lib/static.ts
 */

const fs = require('fs');
const path = require('path');
const { generateVersion } = require('./generate-version');

const STATIC_DIR = 'src/static';
const OUTPUT_FILE = 'src/lib/static.ts';

function readStaticAssets() {
    const assets = {};
    
    function readDirectory(dir, baseRoute = '/static') {
        const files = fs.readdirSync(dir);
        
        for (const file of files) {
            const filePath = path.join(dir, file);
            const stats = fs.statSync(filePath);
            
            if (stats.isFile()) {
                const relativePath = path.relative(STATIC_DIR, filePath);
                const routePath = `${baseRoute}/${relativePath}`.replace(/\\/g, '/'); // Normalize path separators
                
                // Check if it's a binary file
                if (file.endsWith('.png') || file.endsWith('.ico') || file.endsWith('.jpg') || file.endsWith('.jpeg') || file.endsWith('.gif')) {
                    // Read as base64 for binary files
                    const content = fs.readFileSync(filePath, 'base64');
                    assets[routePath] = { content, encoding: 'base64' };
                } else {
                    // Read as text for other files
                    const content = fs.readFileSync(filePath, 'utf8');
                    assets[routePath] = content;
                }
            } else if (stats.isDirectory()) {
                readDirectory(filePath, baseRoute);
            }
        }
    }
    
    try {
        readDirectory(STATIC_DIR);
        console.log(`Embedded ${Object.keys(assets).length} static assets`);
        return assets;
    } catch (error) {
        console.error('‚ùå Error reading static assets:', error.message);
        process.exit(1);
    }
}

function generateStaticModule(assets) {
    const assetEntries = Object.entries(assets)
        .map(([path, content]) => {
            if (typeof content === 'object' && content.encoding === 'base64') {
                // Binary file stored as base64
                return `  '${path}': { content: '${content.content}', encoding: 'base64' }`;
            } else {
                // Text file
                const escapedContent = content
                    .replace(/\\/g, '\\\\')
                    .replace(/`/g, '\\`')
                    .replace(/\${/g, '\\${');
                
                return `  '${path}': \`${escapedContent}\``;
            }
        })
        .join(',\n');

    const moduleContent = `/**
 * Generated static assets for Cloudflare Worker
 * DO NOT EDIT - This file is auto-generated by build-static.js
 */

export const staticAssets: Record<string, string | { content: string; encoding: 'base64' }> = {
${assetEntries}
};

export const assetPaths = Object.keys(staticAssets);
`;

    return moduleContent;
}

function writeStaticModule(content) {
    try {
        // Ensure the lib directory exists
        const libDir = path.dirname(OUTPUT_FILE);
        if (!fs.existsSync(libDir)) {
            fs.mkdirSync(libDir, { recursive: true });
        }
        
        fs.writeFileSync(OUTPUT_FILE, content, 'utf8');
        console.log(`Generated ${OUTPUT_FILE}`);
    } catch (error) {
        console.error('‚ùå Error writing static module:', error.message);
        process.exit(1);
    }
}

function main() {
    console.log('üî® Building static assets for Cloudflare Worker...');
    
    // Generate version.json first
    generateVersion();
    
    const assets = readStaticAssets();
    const moduleContent = generateStaticModule(assets);
    writeStaticModule(moduleContent);
    
    console.log('Build complete!');
}

if (require.main === module) {
    main();
}